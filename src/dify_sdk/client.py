# This file was auto-generated by Fern from our API Definition.

import typing
from .environment import DifyApiEnvironment
import httpx
from .core.client_wrapper import SyncClientWrapper
from .datasets.client import DatasetsClient
from .documents.client import DocumentsClient
from .segments.client import SegmentsClient
from .knowledge_base.client import KnowledgeBaseClient
from .types.post_completion_messages_request_inputs import (
    PostCompletionMessagesRequestInputs,
)
from .types.post_completion_messages_request_response_mode import (
    PostCompletionMessagesRequestResponseMode,
)
from .types.file_input import FileInput
from .core.request_options import RequestOptions
from .types.completion_message import CompletionMessage
from .core.serialization import convert_and_respect_annotation_metadata
from .core.pydantic_utilities import parse_obj_as
from .errors.bad_request_error import BadRequestError
from .types.error import Error
from .errors.not_found_error import NotFoundError
from .errors.internal_server_error import InternalServerError
from json.decoder import JSONDecodeError
from .core.api_error import ApiError
from .types.post_chat_messages_request_response_mode import (
    PostChatMessagesRequestResponseMode,
)
from .types.chat_message import ChatMessage
from .types.post_workflows_run_request_response_mode import (
    PostWorkflowsRunRequestResponseMode,
)
from .types.workflow_message import WorkflowMessage
from . import core
from .types.uploaded_file import UploadedFile
from .errors.content_too_large_error import ContentTooLargeError
from .errors.unsupported_media_type_error import UnsupportedMediaTypeError
from .errors.service_unavailable_error import ServiceUnavailableError
from .types.get_conversations_request_sort_by import GetConversationsRequestSortBy
from .types.get_conversations_response import GetConversationsResponse
from .types.delete_conversations_conversation_id_response import (
    DeleteConversationsConversationIdResponse,
)
from .core.jsonable_encoder import jsonable_encoder
from .types.conversation import Conversation
from .types.get_messages_response import GetMessagesResponse
from .types.post_messages_message_id_feedbacks_response import (
    PostMessagesMessageIdFeedbacksResponse,
)
from .types.post_audio_to_text_response import PostAudioToTextResponse
from .types.get_info_response import GetInfoResponse
from .types.get_parameters_response import GetParametersResponse
from .core.client_wrapper import AsyncClientWrapper
from .datasets.client import AsyncDatasetsClient
from .documents.client import AsyncDocumentsClient
from .segments.client import AsyncSegmentsClient
from .knowledge_base.client import AsyncKnowledgeBaseClient

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class DifyApi:
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propagate to these functions.

    Parameters
    ----------
    base_url : typing.Optional[str]
        The base url to use for requests from the client.

    environment : DifyApiEnvironment
        The environment to use for requests from the client. from .environment import DifyApiEnvironment



        Defaults to DifyApiEnvironment.DEFAULT



    token : typing.Union[str, typing.Callable[[], str]]
    timeout : typing.Optional[float]
        The timeout to be used, in seconds, for requests. By default the timeout is 60 seconds, unless a custom httpx client is used, in which case this default is not enforced.

    follow_redirects : typing.Optional[bool]
        Whether the default httpx client follows redirects or not, this is irrelevant if a custom httpx client is passed in.

    httpx_client : typing.Optional[httpx.Client]
        The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.

    Examples
    --------
    from dify import DifyApi

    client = DifyApi(
        token="YOUR_TOKEN",
    )
    """

    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: DifyApiEnvironment = DifyApiEnvironment.DEFAULT,
        token: typing.Union[str, typing.Callable[[], str]],
        timeout: typing.Optional[float] = None,
        follow_redirects: typing.Optional[bool] = True,
        httpx_client: typing.Optional[httpx.Client] = None,
    ):
        _defaulted_timeout = timeout if timeout is not None else 60 if httpx_client is None else None
        self._client_wrapper = SyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            token=token,
            httpx_client=httpx_client
            if httpx_client is not None
            else httpx.Client(timeout=_defaulted_timeout, follow_redirects=follow_redirects)
            if follow_redirects is not None
            else httpx.Client(timeout=_defaulted_timeout),
            timeout=_defaulted_timeout,
        )
        self.datasets = DatasetsClient(client_wrapper=self._client_wrapper)
        self.documents = DocumentsClient(client_wrapper=self._client_wrapper)
        self.segments = SegmentsClient(client_wrapper=self._client_wrapper)
        self.knowledge_base = KnowledgeBaseClient(client_wrapper=self._client_wrapper)

    def send_message_text_generation_app(
        self,
        *,
        inputs: PostCompletionMessagesRequestInputs,
        response_mode: typing.Optional[PostCompletionMessagesRequestResponseMode] = OMIT,
        user: typing.Optional[str] = OMIT,
        files: typing.Optional[typing.Sequence[FileInput]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CompletionMessage:
        """
        Send request to text generation application

        Parameters
        ----------
        inputs : PostCompletionMessagesRequestInputs

        response_mode : typing.Optional[PostCompletionMessagesRequestResponseMode]
            Response mode:
            - streaming: Streaming mode (recommended), implements typewriter-like output based on SSE
            - blocking: Blocking mode, returns result after execution is complete

        user : typing.Optional[str]
            User identifier

        files : typing.Optional[typing.Sequence[FileInput]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CompletionMessage
            Successful response

        Examples
        --------
        from dify import DifyApi, PostCompletionMessagesRequestInputs

        client = DifyApi(
            token="YOUR_TOKEN",
        )
        client.send_message_text_generation_app(
            inputs=PostCompletionMessagesRequestInputs(
                query="query",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "completion-messages",
            method="POST",
            json={
                "inputs": convert_and_respect_annotation_metadata(
                    object_=inputs,
                    annotation=PostCompletionMessagesRequestInputs,
                    direction="write",
                ),
                "response_mode": response_mode,
                "user": user,
                "files": convert_and_respect_annotation_metadata(
                    object_=files,
                    annotation=typing.Sequence[FileInput],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CompletionMessage,
                    parse_obj_as(
                        type_=CompletionMessage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def send_chat_message_conversational_app(
        self,
        *,
        query: str,
        inputs: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        response_mode: typing.Optional[PostChatMessagesRequestResponseMode] = OMIT,
        user: typing.Optional[str] = OMIT,
        conversation_id: typing.Optional[str] = OMIT,
        files: typing.Optional[typing.Sequence[FileInput]] = OMIT,
        auto_generate_name: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChatMessage:
        """
        Create conversation message

        Parameters
        ----------
        query : str
            User input/question content

        inputs : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Allows passing values for variables defined by the App

        response_mode : typing.Optional[PostChatMessagesRequestResponseMode]
            Response mode:
            - streaming: Streaming mode (recommended), implements typewriter-like output based on SSE
            - blocking: Blocking mode, returns result after execution is complete

        user : typing.Optional[str]
            User identifier

        conversation_id : typing.Optional[str]
            Conversation ID

        files : typing.Optional[typing.Sequence[FileInput]]

        auto_generate_name : typing.Optional[bool]
            Whether to automatically generate title

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChatMessage
            Successful response

        Examples
        --------
        from dify import DifyApi

        client = DifyApi(
            token="YOUR_TOKEN",
        )
        client.send_chat_message_conversational_app(
            query="query",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "chat-messages",
            method="POST",
            json={
                "query": query,
                "inputs": inputs,
                "response_mode": response_mode,
                "user": user,
                "conversation_id": conversation_id,
                "files": convert_and_respect_annotation_metadata(
                    object_=files,
                    annotation=typing.Sequence[FileInput],
                    direction="write",
                ),
                "auto_generate_name": auto_generate_name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ChatMessage,
                    parse_obj_as(
                        type_=ChatMessage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def run_workflow_workflow_app(
        self,
        *,
        inputs: typing.Dict[str, typing.Optional[typing.Any]],
        response_mode: PostWorkflowsRunRequestResponseMode,
        user: str,
        files: typing.Optional[typing.Sequence[FileInput]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WorkflowMessage:
        """
        Execute workflow; cannot be executed without a published workflow

        Parameters
        ----------
        inputs : typing.Dict[str, typing.Optional[typing.Any]]
            Workflow input parameters

        response_mode : PostWorkflowsRunRequestResponseMode
            Response mode

        user : str
            User identifier

        files : typing.Optional[typing.Sequence[FileInput]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowMessage
            Successful response

        Examples
        --------
        from dify import DifyApi

        client = DifyApi(
            token="YOUR_TOKEN",
        )
        client.run_workflow_workflow_app(
            inputs={"key": "value"},
            response_mode="streaming",
            user="user",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "workflows/run",
            method="POST",
            json={
                "inputs": inputs,
                "response_mode": response_mode,
                "user": user,
                "files": convert_and_respect_annotation_metadata(
                    object_=files,
                    annotation=typing.Sequence[FileInput],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    WorkflowMessage,
                    parse_obj_as(
                        type_=WorkflowMessage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def upload_file(
        self,
        *,
        file: core.File,
        user: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UploadedFile:
        """
        Upload files for use when sending messages.
        Supported file types depend on application type and configuration.
        Uploaded files are only available to the current end user.

        Parameters
        ----------
        file : core.File
            See core.File for more documentation

        user : typing.Optional[str]
            User identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UploadedFile
            Successful response

        Examples
        --------
        from dify import DifyApi

        client = DifyApi(
            token="YOUR_TOKEN",
        )
        client.upload_file()
        """
        _response = self._client_wrapper.httpx_client.request(
            "files/upload",
            method="POST",
            data={
                "user": user,
            },
            files={
                "file": file,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    UploadedFile,
                    parse_obj_as(
                        type_=UploadedFile,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_conversation_list(
        self,
        *,
        user: str,
        last_id: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        sort_by: typing.Optional[GetConversationsRequestSortBy] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetConversationsResponse:
        """
        Get conversation list for current user

        Parameters
        ----------
        user : str
            User identifier

        last_id : typing.Optional[str]
            ID of the last record on current page

        limit : typing.Optional[int]
            Records per page

        sort_by : typing.Optional[GetConversationsRequestSortBy]
            Sort field

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetConversationsResponse
            Successful response

        Examples
        --------
        from dify import DifyApi

        client = DifyApi(
            token="YOUR_TOKEN",
        )
        client.get_conversation_list(
            user="user",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "conversations",
            method="GET",
            params={
                "user": user,
                "last_id": last_id,
                "limit": limit,
                "sort_by": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetConversationsResponse,
                    parse_obj_as(
                        type_=GetConversationsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_conversation(
        self,
        conversation_id: str,
        *,
        user: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> DeleteConversationsConversationIdResponse:
        """
        Parameters
        ----------
        conversation_id : str
            Conversation ID

        user : str
            User identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DeleteConversationsConversationIdResponse
            Successful response

        Examples
        --------
        from dify import DifyApi

        client = DifyApi(
            token="YOUR_TOKEN",
        )
        client.delete_conversation(
            conversation_id="conversation_id",
            user="user",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"conversations/{jsonable_encoder(conversation_id)}",
            method="DELETE",
            json={
                "user": user,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    DeleteConversationsConversationIdResponse,
                    parse_obj_as(
                        type_=DeleteConversationsConversationIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def rename_conversation(
        self,
        conversation_id: str,
        *,
        user: str,
        name: typing.Optional[str] = OMIT,
        auto_generate: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Conversation:
        """
        Parameters
        ----------
        conversation_id : str

        user : str
            User identifier

        name : typing.Optional[str]
            New name

        auto_generate : typing.Optional[bool]
            Whether to automatically generate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Conversation
            Successful response

        Examples
        --------
        from dify import DifyApi

        client = DifyApi(
            token="YOUR_TOKEN",
        )
        client.rename_conversation(
            conversation_id="conversation_id",
            user="user",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"conversations/{jsonable_encoder(conversation_id)}/name",
            method="POST",
            json={
                "name": name,
                "auto_generate": auto_generate,
                "user": user,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Conversation,
                    parse_obj_as(
                        type_=Conversation,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_conversation_history_messages(
        self,
        *,
        conversation_id: str,
        user: str,
        first_id: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetMessagesResponse:
        """
        Parameters
        ----------
        conversation_id : str
            Conversation ID

        user : str
            User identifier

        first_id : typing.Optional[str]
            First message ID

        limit : typing.Optional[int]
            Limit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetMessagesResponse
            Successful response

        Examples
        --------
        from dify import DifyApi

        client = DifyApi(
            token="YOUR_TOKEN",
        )
        client.get_conversation_history_messages(
            conversation_id="conversation_id",
            user="user",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "messages",
            method="GET",
            params={
                "conversation_id": conversation_id,
                "user": user,
                "first_id": first_id,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetMessagesResponse,
                    parse_obj_as(
                        type_=GetMessagesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def message_feedback(
        self,
        message_id: str,
        *,
        rating: str,
        user: str,
        content: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PostMessagesMessageIdFeedbacksResponse:
        """
        Parameters
        ----------
        message_id : str
            Message ID

        rating : str
            Feedback type

        user : str
            User identifier

        content : typing.Optional[str]
            Feedback content

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PostMessagesMessageIdFeedbacksResponse
            Successful response

        Examples
        --------
        from dify import DifyApi

        client = DifyApi(
            token="YOUR_TOKEN",
        )
        client.message_feedback(
            message_id="message_id",
            rating="rating",
            user="user",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"messages/{jsonable_encoder(message_id)}/feedbacks",
            method="POST",
            json={
                "rating": rating,
                "user": user,
                "content": content,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PostMessagesMessageIdFeedbacksResponse,
                    parse_obj_as(
                        type_=PostMessagesMessageIdFeedbacksResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def audio_to_text(
        self,
        *,
        file: typing.Optional[core.File] = OMIT,
        user: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PostAudioToTextResponse:
        """
        Parameters
        ----------
        file : typing.Optional[core.File]
            See core.File for more documentation

        user : typing.Optional[str]
            User identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PostAudioToTextResponse
            Successful response

        Examples
        --------
        from dify import DifyApi

        client = DifyApi(
            token="YOUR_TOKEN",
        )
        client.audio_to_text()
        """
        _response = self._client_wrapper.httpx_client.request(
            "audio-to-text",
            method="POST",
            data={
                "user": user,
            },
            files={
                "file": file,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PostAudioToTextResponse,
                    parse_obj_as(
                        type_=PostAudioToTextResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def text_to_audio(
        self,
        *,
        message_id: typing.Optional[str] = OMIT,
        text: typing.Optional[str] = OMIT,
        user: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[bytes]:
        """
        Parameters
        ----------
        message_id : typing.Optional[str]
            Message ID

        text : typing.Optional[str]
            Text to convert

        user : typing.Optional[str]
            User identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration. You can pass in configuration such as `chunk_size`, and more to customize the request and response.

        Yields
        ------
        typing.Iterator[bytes]
            Successful response
        """
        with self._client_wrapper.httpx_client.stream(
            "text-to-audio",
            method="POST",
            json={
                "message_id": message_id,
                "text": text,
                "user": user,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        ) as _response:
            try:
                if 200 <= _response.status_code < 300:
                    _chunk_size = request_options.get("chunk_size", None) if request_options is not None else None
                    for _chunk in _response.iter_bytes(chunk_size=_chunk_size):
                        yield _chunk
                    return
                _response.read()
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_application_basic_information(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> GetInfoResponse:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetInfoResponse
            Successful response

        Examples
        --------
        from dify import DifyApi

        client = DifyApi(
            token="YOUR_TOKEN",
        )
        client.get_application_basic_information()
        """
        _response = self._client_wrapper.httpx_client.request(
            "info",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetInfoResponse,
                    parse_obj_as(
                        type_=GetInfoResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_application_parameters(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> GetParametersResponse:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetParametersResponse
            Successful response

        Examples
        --------
        from dify import DifyApi

        client = DifyApi(
            token="YOUR_TOKEN",
        )
        client.get_application_parameters()
        """
        _response = self._client_wrapper.httpx_client.request(
            "parameters",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetParametersResponse,
                    parse_obj_as(
                        type_=GetParametersResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncDifyApi:
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propagate to these functions.

    Parameters
    ----------
    base_url : typing.Optional[str]
        The base url to use for requests from the client.

    environment : DifyApiEnvironment
        The environment to use for requests from the client. from .environment import DifyApiEnvironment



        Defaults to DifyApiEnvironment.DEFAULT



    token : typing.Union[str, typing.Callable[[], str]]
    timeout : typing.Optional[float]
        The timeout to be used, in seconds, for requests. By default the timeout is 60 seconds, unless a custom httpx client is used, in which case this default is not enforced.

    follow_redirects : typing.Optional[bool]
        Whether the default httpx client follows redirects or not, this is irrelevant if a custom httpx client is passed in.

    httpx_client : typing.Optional[httpx.AsyncClient]
        The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.

    Examples
    --------
    from dify import AsyncDifyApi

    client = AsyncDifyApi(
        token="YOUR_TOKEN",
    )
    """

    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: DifyApiEnvironment = DifyApiEnvironment.DEFAULT,
        token: typing.Union[str, typing.Callable[[], str]],
        timeout: typing.Optional[float] = None,
        follow_redirects: typing.Optional[bool] = True,
        httpx_client: typing.Optional[httpx.AsyncClient] = None,
    ):
        _defaulted_timeout = timeout if timeout is not None else 60 if httpx_client is None else None
        self._client_wrapper = AsyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            token=token,
            httpx_client=httpx_client
            if httpx_client is not None
            else httpx.AsyncClient(timeout=_defaulted_timeout, follow_redirects=follow_redirects)
            if follow_redirects is not None
            else httpx.AsyncClient(timeout=_defaulted_timeout),
            timeout=_defaulted_timeout,
        )
        self.datasets = AsyncDatasetsClient(client_wrapper=self._client_wrapper)
        self.documents = AsyncDocumentsClient(client_wrapper=self._client_wrapper)
        self.segments = AsyncSegmentsClient(client_wrapper=self._client_wrapper)
        self.knowledge_base = AsyncKnowledgeBaseClient(client_wrapper=self._client_wrapper)

    async def send_message_text_generation_app(
        self,
        *,
        inputs: PostCompletionMessagesRequestInputs,
        response_mode: typing.Optional[PostCompletionMessagesRequestResponseMode] = OMIT,
        user: typing.Optional[str] = OMIT,
        files: typing.Optional[typing.Sequence[FileInput]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CompletionMessage:
        """
        Send request to text generation application

        Parameters
        ----------
        inputs : PostCompletionMessagesRequestInputs

        response_mode : typing.Optional[PostCompletionMessagesRequestResponseMode]
            Response mode:
            - streaming: Streaming mode (recommended), implements typewriter-like output based on SSE
            - blocking: Blocking mode, returns result after execution is complete

        user : typing.Optional[str]
            User identifier

        files : typing.Optional[typing.Sequence[FileInput]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CompletionMessage
            Successful response

        Examples
        --------
        import asyncio

        from dify import AsyncDifyApi, PostCompletionMessagesRequestInputs

        client = AsyncDifyApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.send_message_text_generation_app(
                inputs=PostCompletionMessagesRequestInputs(
                    query="query",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "completion-messages",
            method="POST",
            json={
                "inputs": convert_and_respect_annotation_metadata(
                    object_=inputs,
                    annotation=PostCompletionMessagesRequestInputs,
                    direction="write",
                ),
                "response_mode": response_mode,
                "user": user,
                "files": convert_and_respect_annotation_metadata(
                    object_=files,
                    annotation=typing.Sequence[FileInput],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CompletionMessage,
                    parse_obj_as(
                        type_=CompletionMessage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def send_chat_message_conversational_app(
        self,
        *,
        query: str,
        inputs: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        response_mode: typing.Optional[PostChatMessagesRequestResponseMode] = OMIT,
        user: typing.Optional[str] = OMIT,
        conversation_id: typing.Optional[str] = OMIT,
        files: typing.Optional[typing.Sequence[FileInput]] = OMIT,
        auto_generate_name: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ChatMessage:
        """
        Create conversation message

        Parameters
        ----------
        query : str
            User input/question content

        inputs : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Allows passing values for variables defined by the App

        response_mode : typing.Optional[PostChatMessagesRequestResponseMode]
            Response mode:
            - streaming: Streaming mode (recommended), implements typewriter-like output based on SSE
            - blocking: Blocking mode, returns result after execution is complete

        user : typing.Optional[str]
            User identifier

        conversation_id : typing.Optional[str]
            Conversation ID

        files : typing.Optional[typing.Sequence[FileInput]]

        auto_generate_name : typing.Optional[bool]
            Whether to automatically generate title

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ChatMessage
            Successful response

        Examples
        --------
        import asyncio

        from dify import AsyncDifyApi

        client = AsyncDifyApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.send_chat_message_conversational_app(
                query="query",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "chat-messages",
            method="POST",
            json={
                "query": query,
                "inputs": inputs,
                "response_mode": response_mode,
                "user": user,
                "conversation_id": conversation_id,
                "files": convert_and_respect_annotation_metadata(
                    object_=files,
                    annotation=typing.Sequence[FileInput],
                    direction="write",
                ),
                "auto_generate_name": auto_generate_name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ChatMessage,
                    parse_obj_as(
                        type_=ChatMessage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def run_workflow_workflow_app(
        self,
        *,
        inputs: typing.Dict[str, typing.Optional[typing.Any]],
        response_mode: PostWorkflowsRunRequestResponseMode,
        user: str,
        files: typing.Optional[typing.Sequence[FileInput]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> WorkflowMessage:
        """
        Execute workflow; cannot be executed without a published workflow

        Parameters
        ----------
        inputs : typing.Dict[str, typing.Optional[typing.Any]]
            Workflow input parameters

        response_mode : PostWorkflowsRunRequestResponseMode
            Response mode

        user : str
            User identifier

        files : typing.Optional[typing.Sequence[FileInput]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        WorkflowMessage
            Successful response

        Examples
        --------
        import asyncio

        from dify import AsyncDifyApi

        client = AsyncDifyApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.run_workflow_workflow_app(
                inputs={"key": "value"},
                response_mode="streaming",
                user="user",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "workflows/run",
            method="POST",
            json={
                "inputs": inputs,
                "response_mode": response_mode,
                "user": user,
                "files": convert_and_respect_annotation_metadata(
                    object_=files,
                    annotation=typing.Sequence[FileInput],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    WorkflowMessage,
                    parse_obj_as(
                        type_=WorkflowMessage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def upload_file(
        self,
        *,
        file: core.File,
        user: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UploadedFile:
        """
        Upload files for use when sending messages.
        Supported file types depend on application type and configuration.
        Uploaded files are only available to the current end user.

        Parameters
        ----------
        file : core.File
            See core.File for more documentation

        user : typing.Optional[str]
            User identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UploadedFile
            Successful response

        Examples
        --------
        import asyncio

        from dify import AsyncDifyApi

        client = AsyncDifyApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.upload_file()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "files/upload",
            method="POST",
            data={
                "user": user,
            },
            files={
                "file": file,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    UploadedFile,
                    parse_obj_as(
                        type_=UploadedFile,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_conversation_list(
        self,
        *,
        user: str,
        last_id: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        sort_by: typing.Optional[GetConversationsRequestSortBy] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetConversationsResponse:
        """
        Get conversation list for current user

        Parameters
        ----------
        user : str
            User identifier

        last_id : typing.Optional[str]
            ID of the last record on current page

        limit : typing.Optional[int]
            Records per page

        sort_by : typing.Optional[GetConversationsRequestSortBy]
            Sort field

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetConversationsResponse
            Successful response

        Examples
        --------
        import asyncio

        from dify import AsyncDifyApi

        client = AsyncDifyApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.get_conversation_list(
                user="user",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "conversations",
            method="GET",
            params={
                "user": user,
                "last_id": last_id,
                "limit": limit,
                "sort_by": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetConversationsResponse,
                    parse_obj_as(
                        type_=GetConversationsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_conversation(
        self,
        conversation_id: str,
        *,
        user: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> DeleteConversationsConversationIdResponse:
        """
        Parameters
        ----------
        conversation_id : str
            Conversation ID

        user : str
            User identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DeleteConversationsConversationIdResponse
            Successful response

        Examples
        --------
        import asyncio

        from dify import AsyncDifyApi

        client = AsyncDifyApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.delete_conversation(
                conversation_id="conversation_id",
                user="user",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"conversations/{jsonable_encoder(conversation_id)}",
            method="DELETE",
            json={
                "user": user,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    DeleteConversationsConversationIdResponse,
                    parse_obj_as(
                        type_=DeleteConversationsConversationIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def rename_conversation(
        self,
        conversation_id: str,
        *,
        user: str,
        name: typing.Optional[str] = OMIT,
        auto_generate: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Conversation:
        """
        Parameters
        ----------
        conversation_id : str

        user : str
            User identifier

        name : typing.Optional[str]
            New name

        auto_generate : typing.Optional[bool]
            Whether to automatically generate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Conversation
            Successful response

        Examples
        --------
        import asyncio

        from dify import AsyncDifyApi

        client = AsyncDifyApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.rename_conversation(
                conversation_id="conversation_id",
                user="user",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"conversations/{jsonable_encoder(conversation_id)}/name",
            method="POST",
            json={
                "name": name,
                "auto_generate": auto_generate,
                "user": user,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Conversation,
                    parse_obj_as(
                        type_=Conversation,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_conversation_history_messages(
        self,
        *,
        conversation_id: str,
        user: str,
        first_id: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetMessagesResponse:
        """
        Parameters
        ----------
        conversation_id : str
            Conversation ID

        user : str
            User identifier

        first_id : typing.Optional[str]
            First message ID

        limit : typing.Optional[int]
            Limit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetMessagesResponse
            Successful response

        Examples
        --------
        import asyncio

        from dify import AsyncDifyApi

        client = AsyncDifyApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.get_conversation_history_messages(
                conversation_id="conversation_id",
                user="user",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "messages",
            method="GET",
            params={
                "conversation_id": conversation_id,
                "user": user,
                "first_id": first_id,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetMessagesResponse,
                    parse_obj_as(
                        type_=GetMessagesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def message_feedback(
        self,
        message_id: str,
        *,
        rating: str,
        user: str,
        content: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PostMessagesMessageIdFeedbacksResponse:
        """
        Parameters
        ----------
        message_id : str
            Message ID

        rating : str
            Feedback type

        user : str
            User identifier

        content : typing.Optional[str]
            Feedback content

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PostMessagesMessageIdFeedbacksResponse
            Successful response

        Examples
        --------
        import asyncio

        from dify import AsyncDifyApi

        client = AsyncDifyApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.message_feedback(
                message_id="message_id",
                rating="rating",
                user="user",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"messages/{jsonable_encoder(message_id)}/feedbacks",
            method="POST",
            json={
                "rating": rating,
                "user": user,
                "content": content,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PostMessagesMessageIdFeedbacksResponse,
                    parse_obj_as(
                        type_=PostMessagesMessageIdFeedbacksResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def audio_to_text(
        self,
        *,
        file: typing.Optional[core.File] = OMIT,
        user: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PostAudioToTextResponse:
        """
        Parameters
        ----------
        file : typing.Optional[core.File]
            See core.File for more documentation

        user : typing.Optional[str]
            User identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PostAudioToTextResponse
            Successful response

        Examples
        --------
        import asyncio

        from dify import AsyncDifyApi

        client = AsyncDifyApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.audio_to_text()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "audio-to-text",
            method="POST",
            data={
                "user": user,
            },
            files={
                "file": file,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    PostAudioToTextResponse,
                    parse_obj_as(
                        type_=PostAudioToTextResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def text_to_audio(
        self,
        *,
        message_id: typing.Optional[str] = OMIT,
        text: typing.Optional[str] = OMIT,
        user: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[bytes]:
        """
        Parameters
        ----------
        message_id : typing.Optional[str]
            Message ID

        text : typing.Optional[str]
            Text to convert

        user : typing.Optional[str]
            User identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration. You can pass in configuration such as `chunk_size`, and more to customize the request and response.

        Yields
        ------
        typing.AsyncIterator[bytes]
            Successful response
        """
        async with self._client_wrapper.httpx_client.stream(
            "text-to-audio",
            method="POST",
            json={
                "message_id": message_id,
                "text": text,
                "user": user,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        ) as _response:
            try:
                if 200 <= _response.status_code < 300:
                    _chunk_size = request_options.get("chunk_size", None) if request_options is not None else None
                    async for _chunk in _response.aiter_bytes(chunk_size=_chunk_size):
                        yield _chunk
                    return
                await _response.aread()
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_application_basic_information(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> GetInfoResponse:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetInfoResponse
            Successful response

        Examples
        --------
        import asyncio

        from dify import AsyncDifyApi

        client = AsyncDifyApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.get_application_basic_information()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "info",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetInfoResponse,
                    parse_obj_as(
                        type_=GetInfoResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_application_parameters(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> GetParametersResponse:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetParametersResponse
            Successful response

        Examples
        --------
        import asyncio

        from dify import AsyncDifyApi

        client = AsyncDifyApi(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.get_application_parameters()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "parameters",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetParametersResponse,
                    parse_obj_as(
                        type_=GetParametersResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


def _get_base_url(*, base_url: typing.Optional[str] = None, environment: DifyApiEnvironment) -> str:
    if base_url is not None:
        return base_url
    elif environment is not None:
        return environment.value
    else:
        raise Exception("Please pass in either base_url or environment to construct the client")
