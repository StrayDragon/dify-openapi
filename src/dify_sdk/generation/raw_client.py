# This file was auto-generated by Fern from our API Definition.

import contextlib
import typing
from json.decoder import JSONDecodeError

from .. import core
from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.bad_request_error import BadRequestError
from ..errors.content_too_large_error import ContentTooLargeError
from ..errors.internal_server_error import InternalServerError
from ..errors.not_found_error import NotFoundError
from ..errors.service_unavailable_error import ServiceUnavailableError
from ..errors.unsupported_media_type_error import UnsupportedMediaTypeError
from ..types.completion_message import CompletionMessage
from ..types.error import Error
from ..types.file_input import FileInput
from ..types.uploaded_file import UploadedFile
from .types.configure_annotation_reply_by_app_generation_request_action import (
    ConfigureAnnotationReplyByAppGenerationRequestAction,
)
from .types.configure_annotation_reply_by_app_generation_response import ConfigureAnnotationReplyByAppGenerationResponse
from .types.create_annotation_by_app_generation_response import CreateAnnotationByAppGenerationResponse
from .types.delete_annotation_by_app_generation_response import DeleteAnnotationByAppGenerationResponse
from .types.get_annotation_reply_status_by_app_generation_request_action import (
    GetAnnotationReplyStatusByAppGenerationRequestAction,
)
from .types.get_annotation_reply_status_by_app_generation_response import (
    GetAnnotationReplyStatusByAppGenerationResponse,
)
from .types.get_annotations_list_by_app_generation_response import GetAnnotationsListByAppGenerationResponse
from .types.get_app_meta_info_by_app_generation_response import GetAppMetaInfoByAppGenerationResponse
from .types.get_application_info_by_app_generation_response import GetApplicationInfoByAppGenerationResponse
from .types.get_application_parameters_by_app_generation_response import GetApplicationParametersByAppGenerationResponse
from .types.send_completion_message_by_app_generation_request_inputs import (
    SendCompletionMessageByAppGenerationRequestInputs,
)
from .types.send_completion_message_by_app_generation_request_response_mode import (
    SendCompletionMessageByAppGenerationRequestResponseMode,
)
from .types.send_message_feedback_by_app_generation_response import SendMessageFeedbackByAppGenerationResponse
from .types.stop_completion_response_by_app_generation_response import StopCompletionResponseByAppGenerationResponse
from .types.update_annotation_by_app_generation_response import UpdateAnnotationByAppGenerationResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawGenerationClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def send_completion_message_by_app_generation(
        self,
        *,
        inputs: SendCompletionMessageByAppGenerationRequestInputs,
        response_mode: typing.Optional[SendCompletionMessageByAppGenerationRequestResponseMode] = OMIT,
        user: typing.Optional[str] = OMIT,
        files: typing.Optional[typing.Sequence[FileInput]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CompletionMessage]:
        """
        Send request to text generation application

        Parameters
        ----------
        inputs : SendCompletionMessageByAppGenerationRequestInputs

        response_mode : typing.Optional[SendCompletionMessageByAppGenerationRequestResponseMode]
            Response mode:
            - streaming: Streaming mode (recommended), implements typewriter-like output based on SSE
            - blocking: Blocking mode, returns result after execution is complete

        user : typing.Optional[str]
            User identifier

        files : typing.Optional[typing.Sequence[FileInput]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CompletionMessage]
            Successful response
        """
        _response = self._client_wrapper.httpx_client.request(
            "completion-messages",
            method="POST",
            json={
                "inputs": convert_and_respect_annotation_metadata(
                    object_=inputs, annotation=SendCompletionMessageByAppGenerationRequestInputs, direction="write"
                ),
                "response_mode": response_mode,
                "user": user,
                "files": convert_and_respect_annotation_metadata(
                    object_=files, annotation=typing.Sequence[FileInput], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CompletionMessage,
                    parse_obj_as(
                        type_=CompletionMessage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def upload_file_by_app_generation(
        self,
        *,
        file: core.File,
        user: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[UploadedFile]:
        """
        Upload files for use when sending messages.
        Supported file types depend on application type and configuration.
        Uploaded files are only available to the current end user.

        Parameters
        ----------
        file : core.File
            See core.File for more documentation

        user : typing.Optional[str]
            User identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[UploadedFile]
            Successful response
        """
        _response = self._client_wrapper.httpx_client.request(
            "files/upload",
            method="POST",
            data={
                "user": user,
            },
            files={
                "file": file,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UploadedFile,
                    parse_obj_as(
                        type_=UploadedFile,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_application_info_by_app_generation(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetApplicationInfoByAppGenerationResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetApplicationInfoByAppGenerationResponse]
            Successful response
        """
        _response = self._client_wrapper.httpx_client.request(
            "info",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetApplicationInfoByAppGenerationResponse,
                    parse_obj_as(
                        type_=GetApplicationInfoByAppGenerationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_application_parameters_by_app_generation(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetApplicationParametersByAppGenerationResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetApplicationParametersByAppGenerationResponse]
            Successful response
        """
        _response = self._client_wrapper.httpx_client.request(
            "parameters",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetApplicationParametersByAppGenerationResponse,
                    parse_obj_as(
                        type_=GetApplicationParametersByAppGenerationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def stop_completion_response_by_app_generation(
        self, task_id: str, *, user: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[StopCompletionResponseByAppGenerationResponse]:
        """
        Only supports streaming mode

        Parameters
        ----------
        task_id : str
            Task ID, can be obtained from the streaming response chunks

        user : str
            User identifier, must be consistent with the user passed in the message sending interface

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[StopCompletionResponseByAppGenerationResponse]
            Successfully stopped the response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"completion-messages/{jsonable_encoder(task_id)}/stop",
            method="POST",
            json={
                "user": user,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StopCompletionResponseByAppGenerationResponse,
                    parse_obj_as(
                        type_=StopCompletionResponseByAppGenerationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def send_message_feedback_by_app_generation(
        self,
        message_id: str,
        *,
        rating: str,
        user: str,
        content: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SendMessageFeedbackByAppGenerationResponse]:
        """
        End user feedback for messages, helps application developers optimize output expectations

        Parameters
        ----------
        message_id : str
            Message ID

        rating : str
            Like (like), dislike (dislike), or cancel rating (null)

        user : str
            User identifier, defined by developer rules, must be unique within the application

        content : typing.Optional[str]
            Specific feedback information

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SendMessageFeedbackByAppGenerationResponse]
            Successful response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"messages/{jsonable_encoder(message_id)}/feedbacks",
            method="POST",
            json={
                "rating": rating,
                "user": user,
                "content": content,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SendMessageFeedbackByAppGenerationResponse,
                    parse_obj_as(
                        type_=SendMessageFeedbackByAppGenerationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    @contextlib.contextmanager
    def convert_text_to_audio_by_app_generation(
        self,
        *,
        message_id: typing.Optional[str] = OMIT,
        text: typing.Optional[str] = OMIT,
        user: typing.Optional[str] = OMIT,
        streaming: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[HttpResponse[typing.Iterator[bytes]]]:
        """
        Convert text to speech

        Parameters
        ----------
        message_id : typing.Optional[str]
            Dify generated text message ID. The backend will find the corresponding content directly through the message_id to synthesize speech. If both message_id and text are provided, message_id takes precedence

        text : typing.Optional[str]
            Text content for speech generation. If message_id is not provided, this field will be used

        user : typing.Optional[str]
            User identifier, defined by developer rules, must be unique within the application

        streaming : typing.Optional[bool]
            Whether to use streaming mode to return audio data

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration. You can pass in configuration such as `chunk_size`, and more to customize the request and response.

        Returns
        -------
        typing.Iterator[HttpResponse[typing.Iterator[bytes]]]
            Successful response
        """
        with self._client_wrapper.httpx_client.stream(
            "text-to-audio",
            method="POST",
            json={
                "message_id": message_id,
                "text": text,
                "user": user,
                "streaming": streaming,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        ) as _response:

            def stream() -> HttpResponse[typing.Iterator[bytes]]:
                try:
                    if 200 <= _response.status_code < 300:
                        _chunk_size = request_options.get("chunk_size", None) if request_options is not None else None
                        return HttpResponse(
                            response=_response, data=(_chunk for _chunk in _response.iter_bytes(chunk_size=_chunk_size))
                        )
                    _response.read()
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise ApiError(status_code=_response.status_code, body=_response.text)
                raise ApiError(status_code=_response.status_code, body=_response_json)

            yield stream()

    def get_annotations_list_by_app_generation(
        self,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetAnnotationsListByAppGenerationResponse]:
        """
        Get the list of annotations for the application

        Parameters
        ----------
        page : typing.Optional[int]
            Page number

        limit : typing.Optional[int]
            Items per page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetAnnotationsListByAppGenerationResponse]
            Successfully retrieved annotation list
        """
        _response = self._client_wrapper.httpx_client.request(
            "apps/annotations",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAnnotationsListByAppGenerationResponse,
                    parse_obj_as(
                        type_=GetAnnotationsListByAppGenerationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_annotation_by_app_generation(
        self, *, question: str, answer: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[CreateAnnotationByAppGenerationResponse]:
        """
        Create a new annotation

        Parameters
        ----------
        question : str
            Question

        answer : str
            Answer

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateAnnotationByAppGenerationResponse]
            Successfully created annotation
        """
        _response = self._client_wrapper.httpx_client.request(
            "apps/annotations",
            method="POST",
            json={
                "question": question,
                "answer": answer,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateAnnotationByAppGenerationResponse,
                    parse_obj_as(
                        type_=CreateAnnotationByAppGenerationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_annotation_by_app_generation(
        self, annotation_id: str, *, question: str, answer: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[UpdateAnnotationByAppGenerationResponse]:
        """
        Update a specific annotation

        Parameters
        ----------
        annotation_id : str
            Annotation ID

        question : str
            Question

        answer : str
            Answer

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[UpdateAnnotationByAppGenerationResponse]
            Successfully updated annotation
        """
        _response = self._client_wrapper.httpx_client.request(
            f"apps/annotations/{jsonable_encoder(annotation_id)}",
            method="PUT",
            json={
                "question": question,
                "answer": answer,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpdateAnnotationByAppGenerationResponse,
                    parse_obj_as(
                        type_=UpdateAnnotationByAppGenerationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_annotation_by_app_generation(
        self, annotation_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DeleteAnnotationByAppGenerationResponse]:
        """
        Delete a specific annotation

        Parameters
        ----------
        annotation_id : str
            Annotation ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeleteAnnotationByAppGenerationResponse]
            Successfully deleted annotation
        """
        _response = self._client_wrapper.httpx_client.request(
            f"apps/annotations/{jsonable_encoder(annotation_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteAnnotationByAppGenerationResponse,
                    parse_obj_as(
                        type_=DeleteAnnotationByAppGenerationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def configure_annotation_reply_by_app_generation(
        self,
        action: ConfigureAnnotationReplyByAppGenerationRequestAction,
        *,
        embedding_model_provider: typing.Optional[str] = OMIT,
        embedding_provider_name: typing.Optional[str] = OMIT,
        embedding_model: typing.Optional[str] = OMIT,
        embedding_model_name: typing.Optional[str] = OMIT,
        score_threshold: typing.Optional[float] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ConfigureAnnotationReplyByAppGenerationResponse]:
        """
        Enable or disable annotation reply functionality

        Parameters
        ----------
        action : ConfigureAnnotationReplyByAppGenerationRequestAction
            Action, can only be 'enable' or 'disable'

        embedding_model_provider : typing.Optional[str]
            Specified embedding model provider, must be configured in the system first, corresponds to the provider field

        embedding_provider_name : typing.Optional[str]

        embedding_model : typing.Optional[str]
            Specified embedding model, corresponds to the model field

        embedding_model_name : typing.Optional[str]

        score_threshold : typing.Optional[float]
            Similarity score threshold, when similarity is greater than this threshold, the system will automatically reply, otherwise it will not reply

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ConfigureAnnotationReplyByAppGenerationResponse]
            Successfully enabled or disabled annotation reply
        """
        _response = self._client_wrapper.httpx_client.request(
            f"apps/annotation-reply/{jsonable_encoder(action)}",
            method="POST",
            json={
                "embedding_model_provider": embedding_model_provider,
                "embedding_provider_name": embedding_provider_name,
                "embedding_model": embedding_model,
                "embedding_model_name": embedding_model_name,
                "score_threshold": score_threshold,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ConfigureAnnotationReplyByAppGenerationResponse,
                    parse_obj_as(
                        type_=ConfigureAnnotationReplyByAppGenerationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_annotation_reply_status_by_app_generation(
        self,
        action: GetAnnotationReplyStatusByAppGenerationRequestAction,
        job_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetAnnotationReplyStatusByAppGenerationResponse]:
        """
        Query the status of annotation reply initialization task

        Parameters
        ----------
        action : GetAnnotationReplyStatusByAppGenerationRequestAction
            Action, can only be 'enable' or 'disable', and must be consistent with the action in the annotation reply initialization interface

        job_id : str
            Job ID, returned from the annotation reply initialization interface

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetAnnotationReplyStatusByAppGenerationResponse]
            Successfully retrieved job status
        """
        _response = self._client_wrapper.httpx_client.request(
            f"apps/annotation-reply/{jsonable_encoder(action)}/status/{jsonable_encoder(job_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAnnotationReplyStatusByAppGenerationResponse,
                    parse_obj_as(
                        type_=GetAnnotationReplyStatusByAppGenerationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_app_meta_info_by_app_generation(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetAppMetaInfoByAppGenerationResponse]:
        """
        Used to get tool icons

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetAppMetaInfoByAppGenerationResponse]
            Successful response
        """
        _response = self._client_wrapper.httpx_client.request(
            "meta",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAppMetaInfoByAppGenerationResponse,
                    parse_obj_as(
                        type_=GetAppMetaInfoByAppGenerationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncRawGenerationClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def send_completion_message_by_app_generation(
        self,
        *,
        inputs: SendCompletionMessageByAppGenerationRequestInputs,
        response_mode: typing.Optional[SendCompletionMessageByAppGenerationRequestResponseMode] = OMIT,
        user: typing.Optional[str] = OMIT,
        files: typing.Optional[typing.Sequence[FileInput]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CompletionMessage]:
        """
        Send request to text generation application

        Parameters
        ----------
        inputs : SendCompletionMessageByAppGenerationRequestInputs

        response_mode : typing.Optional[SendCompletionMessageByAppGenerationRequestResponseMode]
            Response mode:
            - streaming: Streaming mode (recommended), implements typewriter-like output based on SSE
            - blocking: Blocking mode, returns result after execution is complete

        user : typing.Optional[str]
            User identifier

        files : typing.Optional[typing.Sequence[FileInput]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CompletionMessage]
            Successful response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "completion-messages",
            method="POST",
            json={
                "inputs": convert_and_respect_annotation_metadata(
                    object_=inputs, annotation=SendCompletionMessageByAppGenerationRequestInputs, direction="write"
                ),
                "response_mode": response_mode,
                "user": user,
                "files": convert_and_respect_annotation_metadata(
                    object_=files, annotation=typing.Sequence[FileInput], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CompletionMessage,
                    parse_obj_as(
                        type_=CompletionMessage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def upload_file_by_app_generation(
        self,
        *,
        file: core.File,
        user: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[UploadedFile]:
        """
        Upload files for use when sending messages.
        Supported file types depend on application type and configuration.
        Uploaded files are only available to the current end user.

        Parameters
        ----------
        file : core.File
            See core.File for more documentation

        user : typing.Optional[str]
            User identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[UploadedFile]
            Successful response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "files/upload",
            method="POST",
            data={
                "user": user,
            },
            files={
                "file": file,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UploadedFile,
                    parse_obj_as(
                        type_=UploadedFile,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_application_info_by_app_generation(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetApplicationInfoByAppGenerationResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetApplicationInfoByAppGenerationResponse]
            Successful response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "info",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetApplicationInfoByAppGenerationResponse,
                    parse_obj_as(
                        type_=GetApplicationInfoByAppGenerationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_application_parameters_by_app_generation(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetApplicationParametersByAppGenerationResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetApplicationParametersByAppGenerationResponse]
            Successful response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "parameters",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetApplicationParametersByAppGenerationResponse,
                    parse_obj_as(
                        type_=GetApplicationParametersByAppGenerationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def stop_completion_response_by_app_generation(
        self, task_id: str, *, user: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[StopCompletionResponseByAppGenerationResponse]:
        """
        Only supports streaming mode

        Parameters
        ----------
        task_id : str
            Task ID, can be obtained from the streaming response chunks

        user : str
            User identifier, must be consistent with the user passed in the message sending interface

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[StopCompletionResponseByAppGenerationResponse]
            Successfully stopped the response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"completion-messages/{jsonable_encoder(task_id)}/stop",
            method="POST",
            json={
                "user": user,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StopCompletionResponseByAppGenerationResponse,
                    parse_obj_as(
                        type_=StopCompletionResponseByAppGenerationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def send_message_feedback_by_app_generation(
        self,
        message_id: str,
        *,
        rating: str,
        user: str,
        content: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SendMessageFeedbackByAppGenerationResponse]:
        """
        End user feedback for messages, helps application developers optimize output expectations

        Parameters
        ----------
        message_id : str
            Message ID

        rating : str
            Like (like), dislike (dislike), or cancel rating (null)

        user : str
            User identifier, defined by developer rules, must be unique within the application

        content : typing.Optional[str]
            Specific feedback information

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SendMessageFeedbackByAppGenerationResponse]
            Successful response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"messages/{jsonable_encoder(message_id)}/feedbacks",
            method="POST",
            json={
                "rating": rating,
                "user": user,
                "content": content,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SendMessageFeedbackByAppGenerationResponse,
                    parse_obj_as(
                        type_=SendMessageFeedbackByAppGenerationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    @contextlib.asynccontextmanager
    async def convert_text_to_audio_by_app_generation(
        self,
        *,
        message_id: typing.Optional[str] = OMIT,
        text: typing.Optional[str] = OMIT,
        user: typing.Optional[str] = OMIT,
        streaming: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[AsyncHttpResponse[typing.AsyncIterator[bytes]]]:
        """
        Convert text to speech

        Parameters
        ----------
        message_id : typing.Optional[str]
            Dify generated text message ID. The backend will find the corresponding content directly through the message_id to synthesize speech. If both message_id and text are provided, message_id takes precedence

        text : typing.Optional[str]
            Text content for speech generation. If message_id is not provided, this field will be used

        user : typing.Optional[str]
            User identifier, defined by developer rules, must be unique within the application

        streaming : typing.Optional[bool]
            Whether to use streaming mode to return audio data

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration. You can pass in configuration such as `chunk_size`, and more to customize the request and response.

        Returns
        -------
        typing.AsyncIterator[AsyncHttpResponse[typing.AsyncIterator[bytes]]]
            Successful response
        """
        async with self._client_wrapper.httpx_client.stream(
            "text-to-audio",
            method="POST",
            json={
                "message_id": message_id,
                "text": text,
                "user": user,
                "streaming": streaming,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        ) as _response:

            async def stream() -> AsyncHttpResponse[typing.AsyncIterator[bytes]]:
                try:
                    if 200 <= _response.status_code < 300:
                        _chunk_size = request_options.get("chunk_size", None) if request_options is not None else None
                        return AsyncHttpResponse(
                            response=_response,
                            data=(_chunk async for _chunk in _response.aiter_bytes(chunk_size=_chunk_size)),
                        )
                    await _response.aread()
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise ApiError(status_code=_response.status_code, body=_response.text)
                raise ApiError(status_code=_response.status_code, body=_response_json)

            yield await stream()

    async def get_annotations_list_by_app_generation(
        self,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetAnnotationsListByAppGenerationResponse]:
        """
        Get the list of annotations for the application

        Parameters
        ----------
        page : typing.Optional[int]
            Page number

        limit : typing.Optional[int]
            Items per page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetAnnotationsListByAppGenerationResponse]
            Successfully retrieved annotation list
        """
        _response = await self._client_wrapper.httpx_client.request(
            "apps/annotations",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAnnotationsListByAppGenerationResponse,
                    parse_obj_as(
                        type_=GetAnnotationsListByAppGenerationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_annotation_by_app_generation(
        self, *, question: str, answer: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[CreateAnnotationByAppGenerationResponse]:
        """
        Create a new annotation

        Parameters
        ----------
        question : str
            Question

        answer : str
            Answer

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateAnnotationByAppGenerationResponse]
            Successfully created annotation
        """
        _response = await self._client_wrapper.httpx_client.request(
            "apps/annotations",
            method="POST",
            json={
                "question": question,
                "answer": answer,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateAnnotationByAppGenerationResponse,
                    parse_obj_as(
                        type_=CreateAnnotationByAppGenerationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_annotation_by_app_generation(
        self, annotation_id: str, *, question: str, answer: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[UpdateAnnotationByAppGenerationResponse]:
        """
        Update a specific annotation

        Parameters
        ----------
        annotation_id : str
            Annotation ID

        question : str
            Question

        answer : str
            Answer

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[UpdateAnnotationByAppGenerationResponse]
            Successfully updated annotation
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"apps/annotations/{jsonable_encoder(annotation_id)}",
            method="PUT",
            json={
                "question": question,
                "answer": answer,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpdateAnnotationByAppGenerationResponse,
                    parse_obj_as(
                        type_=UpdateAnnotationByAppGenerationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_annotation_by_app_generation(
        self, annotation_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DeleteAnnotationByAppGenerationResponse]:
        """
        Delete a specific annotation

        Parameters
        ----------
        annotation_id : str
            Annotation ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeleteAnnotationByAppGenerationResponse]
            Successfully deleted annotation
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"apps/annotations/{jsonable_encoder(annotation_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteAnnotationByAppGenerationResponse,
                    parse_obj_as(
                        type_=DeleteAnnotationByAppGenerationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def configure_annotation_reply_by_app_generation(
        self,
        action: ConfigureAnnotationReplyByAppGenerationRequestAction,
        *,
        embedding_model_provider: typing.Optional[str] = OMIT,
        embedding_provider_name: typing.Optional[str] = OMIT,
        embedding_model: typing.Optional[str] = OMIT,
        embedding_model_name: typing.Optional[str] = OMIT,
        score_threshold: typing.Optional[float] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ConfigureAnnotationReplyByAppGenerationResponse]:
        """
        Enable or disable annotation reply functionality

        Parameters
        ----------
        action : ConfigureAnnotationReplyByAppGenerationRequestAction
            Action, can only be 'enable' or 'disable'

        embedding_model_provider : typing.Optional[str]
            Specified embedding model provider, must be configured in the system first, corresponds to the provider field

        embedding_provider_name : typing.Optional[str]

        embedding_model : typing.Optional[str]
            Specified embedding model, corresponds to the model field

        embedding_model_name : typing.Optional[str]

        score_threshold : typing.Optional[float]
            Similarity score threshold, when similarity is greater than this threshold, the system will automatically reply, otherwise it will not reply

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ConfigureAnnotationReplyByAppGenerationResponse]
            Successfully enabled or disabled annotation reply
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"apps/annotation-reply/{jsonable_encoder(action)}",
            method="POST",
            json={
                "embedding_model_provider": embedding_model_provider,
                "embedding_provider_name": embedding_provider_name,
                "embedding_model": embedding_model,
                "embedding_model_name": embedding_model_name,
                "score_threshold": score_threshold,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ConfigureAnnotationReplyByAppGenerationResponse,
                    parse_obj_as(
                        type_=ConfigureAnnotationReplyByAppGenerationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_annotation_reply_status_by_app_generation(
        self,
        action: GetAnnotationReplyStatusByAppGenerationRequestAction,
        job_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetAnnotationReplyStatusByAppGenerationResponse]:
        """
        Query the status of annotation reply initialization task

        Parameters
        ----------
        action : GetAnnotationReplyStatusByAppGenerationRequestAction
            Action, can only be 'enable' or 'disable', and must be consistent with the action in the annotation reply initialization interface

        job_id : str
            Job ID, returned from the annotation reply initialization interface

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetAnnotationReplyStatusByAppGenerationResponse]
            Successfully retrieved job status
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"apps/annotation-reply/{jsonable_encoder(action)}/status/{jsonable_encoder(job_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAnnotationReplyStatusByAppGenerationResponse,
                    parse_obj_as(
                        type_=GetAnnotationReplyStatusByAppGenerationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_app_meta_info_by_app_generation(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetAppMetaInfoByAppGenerationResponse]:
        """
        Used to get tool icons

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetAppMetaInfoByAppGenerationResponse]
            Successful response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "meta",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAppMetaInfoByAppGenerationResponse,
                    parse_obj_as(
                        type_=GetAppMetaInfoByAppGenerationResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
