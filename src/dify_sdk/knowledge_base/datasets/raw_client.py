# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.http_response import AsyncHttpResponse, HttpResponse
from ...core.jsonable_encoder import jsonable_encoder
from ...core.pydantic_utilities import parse_obj_as
from ...core.request_options import RequestOptions
from ...core.serialization import convert_and_respect_annotation_metadata
from ..errors.bad_request_error import BadRequestError
from ..errors.conflict_error import ConflictError
from ..errors.forbidden_error import ForbiddenError
from ..types.dataset import Dataset
from ..types.dataset_list import DatasetList
from ..types.error import Error
from ..types.retrieval_model import RetrievalModel
from .types.create_dataset_request_indexing_technique import CreateDatasetRequestIndexingTechnique
from .types.create_dataset_request_permission import CreateDatasetRequestPermission
from .types.create_dataset_request_provider import CreateDatasetRequestProvider
from .types.patch_datasets_dataset_id_request_indexing_technique import PatchDatasetsDatasetIdRequestIndexingTechnique
from .types.patch_datasets_dataset_id_request_permission import PatchDatasetsDatasetIdRequestPermission
from .types.retrieve_dataset_response import RetrieveDatasetResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawDatasetsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_dataset_list(
        self,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[DatasetList]:
        """
        Get a list of all knowledge bases

        Parameters
        ----------
        page : typing.Optional[int]
            Page number

        limit : typing.Optional[int]
            Number of items per page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DatasetList]
            Successfully retrieved knowledge base list
        """
        _response = self._client_wrapper.httpx_client.request(
            "datasets",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DatasetList,
                    parse_obj_as(
                        type_=DatasetList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def create_empty_dataset(
        self,
        *,
        name: str,
        description: typing.Optional[str] = OMIT,
        indexing_technique: typing.Optional[CreateDatasetRequestIndexingTechnique] = OMIT,
        permission: typing.Optional[CreateDatasetRequestPermission] = OMIT,
        provider: typing.Optional[CreateDatasetRequestProvider] = OMIT,
        external_knowledge_api_id: typing.Optional[str] = OMIT,
        external_knowledge_id: typing.Optional[str] = OMIT,
        embedding_model: typing.Optional[str] = OMIT,
        embedding_model_provider: typing.Optional[str] = OMIT,
        retrieval_model: typing.Optional[RetrievalModel] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Dataset]:
        """
        Create a new empty knowledge base

        Parameters
        ----------
        name : str
            Knowledge Base name (required)

        description : typing.Optional[str]
            Knowledge Base description (optional)

        indexing_technique : typing.Optional[CreateDatasetRequestIndexingTechnique]
            Indexing mode (optional, recommended)
            - high_quality: High quality
            - economy: Economy

        permission : typing.Optional[CreateDatasetRequestPermission]
            Permission (optional, default only_me)
            - only_me: Only me
            - all_team_members: All team members
            - partial_members: Partial team members

        provider : typing.Optional[CreateDatasetRequestProvider]
            Provider (optional, default vendor)
            - vendor: Upload files
            - external: External knowledge base

        external_knowledge_api_id : typing.Optional[str]
            External knowledge API_ID (optional)

        external_knowledge_id : typing.Optional[str]
            External knowledge ID (optional)

        embedding_model : typing.Optional[str]
            Embedding model name

        embedding_model_provider : typing.Optional[str]
            Embedding model provider

        retrieval_model : typing.Optional[RetrievalModel]
            Retrieval model configuration

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Dataset]
            Successfully created knowledge base
        """
        _response = self._client_wrapper.httpx_client.request(
            "datasets",
            method="POST",
            json={
                "name": name,
                "description": description,
                "indexing_technique": indexing_technique,
                "permission": permission,
                "provider": provider,
                "external_knowledge_api_id": external_knowledge_api_id,
                "external_knowledge_id": external_knowledge_id,
                "embedding_model": embedding_model,
                "embedding_model_provider": embedding_model_provider,
                "retrieval_model": convert_and_respect_annotation_metadata(
                    object_=retrieval_model, annotation=RetrievalModel, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Dataset,
                    parse_obj_as(
                        type_=Dataset,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def view_knowledge_base_details(
        self, dataset_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[Dataset]:
        """
        Get detailed information about a specific knowledge base

        Parameters
        ----------
        dataset_id : str
            Knowledge Base ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Dataset]
            Successfully retrieved knowledge base details
        """
        _response = self._client_wrapper.httpx_client.request(
            f"datasets/{jsonable_encoder(dataset_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Dataset,
                    parse_obj_as(
                        type_=Dataset,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def delete_dataset(
        self, dataset_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Delete specified knowledge base

        Parameters
        ----------
        dataset_id : str
            Knowledge Base ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"datasets/{jsonable_encoder(dataset_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def update_knowledge_base_details(
        self,
        dataset_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        indexing_technique: typing.Optional[PatchDatasetsDatasetIdRequestIndexingTechnique] = OMIT,
        permission: typing.Optional[PatchDatasetsDatasetIdRequestPermission] = OMIT,
        embedding_model_provider: typing.Optional[str] = OMIT,
        embedding_model: typing.Optional[str] = OMIT,
        retrieval_model: typing.Optional[str] = OMIT,
        partial_member_list: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Dataset]:
        """
        Modify details of a specific knowledge base

        Parameters
        ----------
        dataset_id : str
            Knowledge Base ID

        name : typing.Optional[str]
            Knowledge Base name (optional)

        indexing_technique : typing.Optional[PatchDatasetsDatasetIdRequestIndexingTechnique]
            Indexing mode (optional, recommended)
            - high_quality: High quality
            - economy: Economy

        permission : typing.Optional[PatchDatasetsDatasetIdRequestPermission]
            Permission (optional, default only_me)
            - only_me: Only me
            - all_team_members: All team members
            - partial_members: Partial team members

        embedding_model_provider : typing.Optional[str]
            Embedding model provider (optional), must be configured in the system first, corresponds to the provider field

        embedding_model : typing.Optional[str]
            Embedding model (optional)

        retrieval_model : typing.Optional[str]
            Retrieval model (optional)

        partial_member_list : typing.Optional[typing.Sequence[str]]
            Partial team members ID list (optional)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Dataset]
            Successfully updated knowledge base details
        """
        _response = self._client_wrapper.httpx_client.request(
            f"datasets/{jsonable_encoder(dataset_id)}",
            method="PATCH",
            json={
                "name": name,
                "indexing_technique": indexing_technique,
                "permission": permission,
                "embedding_model_provider": embedding_model_provider,
                "embedding_model": embedding_model,
                "retrieval_model": retrieval_model,
                "partial_member_list": partial_member_list,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Dataset,
                    parse_obj_as(
                        type_=Dataset,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def retrieve_dataset(
        self,
        dataset_id: str,
        *,
        query: str,
        retrieval_model: typing.Optional[RetrievalModel] = OMIT,
        external_retrieval_model: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[RetrieveDatasetResponse]:
        """
        Retrieve relevant content from the specified knowledge base

        Parameters
        ----------
        dataset_id : str
            Knowledge Base ID

        query : str
            Search keywords

        retrieval_model : typing.Optional[RetrievalModel]
            Retrieval parameter configuration

        external_retrieval_model : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            External retrieval model (disabled field)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[RetrieveDatasetResponse]
            Successfully retrieved knowledge base
        """
        _response = self._client_wrapper.httpx_client.request(
            f"datasets/{jsonable_encoder(dataset_id)}/retrieve",
            method="POST",
            json={
                "query": query,
                "retrieval_model": convert_and_respect_annotation_metadata(
                    object_=retrieval_model, annotation=RetrievalModel, direction="write"
                ),
                "external_retrieval_model": external_retrieval_model,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RetrieveDatasetResponse,
                    parse_obj_as(
                        type_=RetrieveDatasetResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)


class AsyncRawDatasetsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_dataset_list(
        self,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[DatasetList]:
        """
        Get a list of all knowledge bases

        Parameters
        ----------
        page : typing.Optional[int]
            Page number

        limit : typing.Optional[int]
            Number of items per page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DatasetList]
            Successfully retrieved knowledge base list
        """
        _response = await self._client_wrapper.httpx_client.request(
            "datasets",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DatasetList,
                    parse_obj_as(
                        type_=DatasetList,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def create_empty_dataset(
        self,
        *,
        name: str,
        description: typing.Optional[str] = OMIT,
        indexing_technique: typing.Optional[CreateDatasetRequestIndexingTechnique] = OMIT,
        permission: typing.Optional[CreateDatasetRequestPermission] = OMIT,
        provider: typing.Optional[CreateDatasetRequestProvider] = OMIT,
        external_knowledge_api_id: typing.Optional[str] = OMIT,
        external_knowledge_id: typing.Optional[str] = OMIT,
        embedding_model: typing.Optional[str] = OMIT,
        embedding_model_provider: typing.Optional[str] = OMIT,
        retrieval_model: typing.Optional[RetrievalModel] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Dataset]:
        """
        Create a new empty knowledge base

        Parameters
        ----------
        name : str
            Knowledge Base name (required)

        description : typing.Optional[str]
            Knowledge Base description (optional)

        indexing_technique : typing.Optional[CreateDatasetRequestIndexingTechnique]
            Indexing mode (optional, recommended)
            - high_quality: High quality
            - economy: Economy

        permission : typing.Optional[CreateDatasetRequestPermission]
            Permission (optional, default only_me)
            - only_me: Only me
            - all_team_members: All team members
            - partial_members: Partial team members

        provider : typing.Optional[CreateDatasetRequestProvider]
            Provider (optional, default vendor)
            - vendor: Upload files
            - external: External knowledge base

        external_knowledge_api_id : typing.Optional[str]
            External knowledge API_ID (optional)

        external_knowledge_id : typing.Optional[str]
            External knowledge ID (optional)

        embedding_model : typing.Optional[str]
            Embedding model name

        embedding_model_provider : typing.Optional[str]
            Embedding model provider

        retrieval_model : typing.Optional[RetrievalModel]
            Retrieval model configuration

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Dataset]
            Successfully created knowledge base
        """
        _response = await self._client_wrapper.httpx_client.request(
            "datasets",
            method="POST",
            json={
                "name": name,
                "description": description,
                "indexing_technique": indexing_technique,
                "permission": permission,
                "provider": provider,
                "external_knowledge_api_id": external_knowledge_api_id,
                "external_knowledge_id": external_knowledge_id,
                "embedding_model": embedding_model,
                "embedding_model_provider": embedding_model_provider,
                "retrieval_model": convert_and_respect_annotation_metadata(
                    object_=retrieval_model, annotation=RetrievalModel, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Dataset,
                    parse_obj_as(
                        type_=Dataset,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def view_knowledge_base_details(
        self, dataset_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[Dataset]:
        """
        Get detailed information about a specific knowledge base

        Parameters
        ----------
        dataset_id : str
            Knowledge Base ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Dataset]
            Successfully retrieved knowledge base details
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"datasets/{jsonable_encoder(dataset_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Dataset,
                    parse_obj_as(
                        type_=Dataset,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def delete_dataset(
        self, dataset_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Delete specified knowledge base

        Parameters
        ----------
        dataset_id : str
            Knowledge Base ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"datasets/{jsonable_encoder(dataset_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def update_knowledge_base_details(
        self,
        dataset_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        indexing_technique: typing.Optional[PatchDatasetsDatasetIdRequestIndexingTechnique] = OMIT,
        permission: typing.Optional[PatchDatasetsDatasetIdRequestPermission] = OMIT,
        embedding_model_provider: typing.Optional[str] = OMIT,
        embedding_model: typing.Optional[str] = OMIT,
        retrieval_model: typing.Optional[str] = OMIT,
        partial_member_list: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Dataset]:
        """
        Modify details of a specific knowledge base

        Parameters
        ----------
        dataset_id : str
            Knowledge Base ID

        name : typing.Optional[str]
            Knowledge Base name (optional)

        indexing_technique : typing.Optional[PatchDatasetsDatasetIdRequestIndexingTechnique]
            Indexing mode (optional, recommended)
            - high_quality: High quality
            - economy: Economy

        permission : typing.Optional[PatchDatasetsDatasetIdRequestPermission]
            Permission (optional, default only_me)
            - only_me: Only me
            - all_team_members: All team members
            - partial_members: Partial team members

        embedding_model_provider : typing.Optional[str]
            Embedding model provider (optional), must be configured in the system first, corresponds to the provider field

        embedding_model : typing.Optional[str]
            Embedding model (optional)

        retrieval_model : typing.Optional[str]
            Retrieval model (optional)

        partial_member_list : typing.Optional[typing.Sequence[str]]
            Partial team members ID list (optional)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Dataset]
            Successfully updated knowledge base details
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"datasets/{jsonable_encoder(dataset_id)}",
            method="PATCH",
            json={
                "name": name,
                "indexing_technique": indexing_technique,
                "permission": permission,
                "embedding_model_provider": embedding_model_provider,
                "embedding_model": embedding_model,
                "retrieval_model": retrieval_model,
                "partial_member_list": partial_member_list,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Dataset,
                    parse_obj_as(
                        type_=Dataset,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def retrieve_dataset(
        self,
        dataset_id: str,
        *,
        query: str,
        retrieval_model: typing.Optional[RetrievalModel] = OMIT,
        external_retrieval_model: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[RetrieveDatasetResponse]:
        """
        Retrieve relevant content from the specified knowledge base

        Parameters
        ----------
        dataset_id : str
            Knowledge Base ID

        query : str
            Search keywords

        retrieval_model : typing.Optional[RetrievalModel]
            Retrieval parameter configuration

        external_retrieval_model : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            External retrieval model (disabled field)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[RetrieveDatasetResponse]
            Successfully retrieved knowledge base
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"datasets/{jsonable_encoder(dataset_id)}/retrieve",
            method="POST",
            json={
                "query": query,
                "retrieval_model": convert_and_respect_annotation_metadata(
                    object_=retrieval_model, annotation=RetrievalModel, direction="write"
                ),
                "external_retrieval_model": external_retrieval_model,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RetrieveDatasetResponse,
                    parse_obj_as(
                        type_=RetrieveDatasetResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)
