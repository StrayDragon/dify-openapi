# This file was auto-generated by Fern from our API Definition.

import contextlib
import typing
from json.decoder import JSONDecodeError

import httpx_sse
from .. import core
from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from .errors.bad_request_error import BadRequestError
from .errors.content_too_large_error import ContentTooLargeError
from .errors.internal_server_error import InternalServerError
from .errors.not_found_error import NotFoundError
from .errors.service_unavailable_error import ServiceUnavailableError
from .errors.unsupported_media_type_error import UnsupportedMediaTypeError
from .types.chunk_chat_completion_response import ChunkChatCompletionResponse
from .types.configure_annotation_reply_by_app_chat_request_action import ConfigureAnnotationReplyByAppChatRequestAction
from .types.configure_annotation_reply_by_app_chat_response import ConfigureAnnotationReplyByAppChatResponse
from .types.conversation import Conversation
from .types.convert_audio_to_text_by_app_chat_response import ConvertAudioToTextByAppChatResponse
from .types.create_annotation_by_app_chat_response import CreateAnnotationByAppChatResponse
from .types.delete_annotation_by_app_chat_response import DeleteAnnotationByAppChatResponse
from .types.error import Error
from .types.get_annotation_reply_status_by_app_chat_request_action import GetAnnotationReplyStatusByAppChatRequestAction
from .types.get_annotation_reply_status_by_app_chat_response import GetAnnotationReplyStatusByAppChatResponse
from .types.get_annotations_list_by_app_chat_response import GetAnnotationsListByAppChatResponse
from .types.get_app_feedbacks_by_app_chat_response import GetAppFeedbacksByAppChatResponse
from .types.get_app_meta_info_by_app_chat_response import GetAppMetaInfoByAppChatResponse
from .types.get_app_site_settings_by_app_chat_response import GetAppSiteSettingsByAppChatResponse
from .types.get_application_info_by_app_chat_response import GetApplicationInfoByAppChatResponse
from .types.get_application_parameters_by_app_chat_response import GetApplicationParametersByAppChatResponse
from .types.get_conversation_list_by_app_chat_request_sort_by import GetConversationListByAppChatRequestSortBy
from .types.get_conversation_list_by_app_chat_response import GetConversationListByAppChatResponse
from .types.get_conversation_messages_by_app_chat_response import GetConversationMessagesByAppChatResponse
from .types.get_conversation_variables_by_app_chat_response import GetConversationVariablesByAppChatResponse
from .types.get_suggested_questions_by_app_chat_response import GetSuggestedQuestionsByAppChatResponse
from .types.send_chat_message_by_app_chat_request_files_item import SendChatMessageByAppChatRequestFilesItem
from .types.send_chat_message_by_app_chat_request_response_mode import SendChatMessageByAppChatRequestResponseMode
from .types.send_message_feedback_by_app_chat_response import SendMessageFeedbackByAppChatResponse
from .types.stop_chat_response_by_app_chat_response import StopChatResponseByAppChatResponse
from .types.update_annotation_by_app_chat_response import UpdateAnnotationByAppChatResponse
from .types.uploaded_file import UploadedFile

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawChatClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    @contextlib.contextmanager
    def send_chat_message_by_app_chat(
        self,
        *,
        query: str,
        inputs: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        response_mode: typing.Optional[SendChatMessageByAppChatRequestResponseMode] = OMIT,
        user: typing.Optional[str] = OMIT,
        conversation_id: typing.Optional[str] = OMIT,
        files: typing.Optional[typing.Sequence[SendChatMessageByAppChatRequestFilesItem]] = OMIT,
        auto_generate_name: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[HttpResponse[typing.Iterator[ChunkChatCompletionResponse]]]:
        """
        Create conversation message

        Parameters
        ----------
        query : str
            User input/question content

        inputs : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Allows passing values for variables defined by the App. The inputs parameter contains multiple key/value pairs, where each key corresponds to a specific variable and each value is the value for that variable. Default {}

        response_mode : typing.Optional[SendChatMessageByAppChatRequestResponseMode]
            Response mode:
            - streaming: Streaming mode (recommended), implements typewriter-like output based on SSE
            - blocking: Blocking mode, returns result after execution is complete (request may be interrupted if the process is too long)
            Note: Blocking mode is not allowed in Agent mode

        user : typing.Optional[str]
            User identifier for defining end user identity, facilitating retrieval and statistics. Defined by developer rules, must be unique within the application. Service API will not share conversations created by WebApp.

        conversation_id : typing.Optional[str]
            (Optional) Conversation ID. Required when continuing a conversation based on previous chat history, must pass the conversation_id from previous messages

        files : typing.Optional[typing.Sequence[SendChatMessageByAppChatRequestFilesItem]]
            Uploaded files

        auto_generate_name : typing.Optional[bool]
            (Optional) Whether to automatically generate title, default is true. If set to false, you can call the conversation rename interface and set auto_generate to true to generate a title asynchronously.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.Iterator[HttpResponse[typing.Iterator[ChunkChatCompletionResponse]]]
            Successful response
        """
        with self._client_wrapper.httpx_client.stream(
            "chat-messages",
            method="POST",
            json={
                "query": query,
                "inputs": inputs,
                "response_mode": response_mode,
                "user": user,
                "conversation_id": conversation_id,
                "files": convert_and_respect_annotation_metadata(
                    object_=files,
                    annotation=typing.Sequence[SendChatMessageByAppChatRequestFilesItem],
                    direction="write",
                ),
                "auto_generate_name": auto_generate_name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        ) as _response:

            def stream() -> HttpResponse[typing.Iterator[ChunkChatCompletionResponse]]:
                try:
                    if 200 <= _response.status_code < 300:

                        def _iter():
                            _event_source = httpx_sse.EventSource(_response)
                            for _sse in _event_source.iter_sse():
                                if _sse.data == None:
                                    return
                                try:
                                    yield _sse.data
                                except Exception:
                                    pass
                            return

                        return HttpResponse(response=_response, data=_iter())
                    _response.read()
                    if _response.status_code == 400:
                        raise BadRequestError(
                            typing.cast(
                                Error,
                                parse_obj_as(
                                    type_=Error,  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    if _response.status_code == 404:
                        raise NotFoundError(
                            typing.cast(
                                typing.Optional[typing.Any],
                                parse_obj_as(
                                    type_=typing.Optional[typing.Any],  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    if _response.status_code == 500:
                        raise InternalServerError(
                            typing.cast(
                                Error,
                                parse_obj_as(
                                    type_=Error,  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise ApiError(
                        headers=dict(_response.headers), status_code=_response.status_code, body=_response.text
                    )
                raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

            yield stream()

    def get_conversation_list_by_app_chat(
        self,
        *,
        user: str,
        last_id: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        sort_by: typing.Optional[GetConversationListByAppChatRequestSortBy] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetConversationListByAppChatResponse]:
        """
        Get conversation list for current user

        Parameters
        ----------
        user : str
            User identifier

        last_id : typing.Optional[str]
            ID of the last record on current page

        limit : typing.Optional[int]
            Records per page

        sort_by : typing.Optional[GetConversationListByAppChatRequestSortBy]
            Sort field

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetConversationListByAppChatResponse]
            Successful response
        """
        _response = self._client_wrapper.httpx_client.request(
            "conversations",
            method="GET",
            params={
                "user": user,
                "last_id": last_id,
                "limit": limit,
                "sort_by": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetConversationListByAppChatResponse,
                    parse_obj_as(
                        type_=GetConversationListByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def delete_conversation_by_app_chat(
        self, conversation_id: str, *, user: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[None]:
        """
        Parameters
        ----------
        conversation_id : str
            Conversation ID

        user : str
            User identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[None]
        """
        _response = self._client_wrapper.httpx_client.request(
            f"conversations/{jsonable_encoder(conversation_id)}",
            method="DELETE",
            json={
                "user": user,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return HttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def rename_conversation_by_app_chat(
        self,
        conversation_id: str,
        *,
        user: str,
        name: typing.Optional[str] = OMIT,
        auto_generate: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[Conversation]:
        """
        Parameters
        ----------
        conversation_id : str

        user : str
            User identifier

        name : typing.Optional[str]
            New name

        auto_generate : typing.Optional[bool]
            Whether to automatically generate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[Conversation]
            Successful response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"conversations/{jsonable_encoder(conversation_id)}/name",
            method="POST",
            json={
                "name": name,
                "auto_generate": auto_generate,
                "user": user,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Conversation,
                    parse_obj_as(
                        type_=Conversation,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def get_conversation_variables_by_app_chat(
        self,
        conversation_id: str,
        *,
        user: str,
        last_id: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetConversationVariablesByAppChatResponse]:
        """
        Retrieve variables from a specific conversation. This endpoint is useful for extracting structured data captured during conversations.

        Parameters
        ----------
        conversation_id : str
            ID of the conversation to retrieve variables from

        user : str
            User identifier, defined by developer rules, must be unique within the application. Service API will not share conversations created by WebApp.

        last_id : typing.Optional[str]
            (Optional) ID of the last record on the current page, default null

        limit : typing.Optional[int]
            (Optional) Number of records to return per request, default 20, max 100, min 1

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetConversationVariablesByAppChatResponse]
            Successfully retrieved variables
        """
        _response = self._client_wrapper.httpx_client.request(
            f"conversations/{jsonable_encoder(conversation_id)}/variables",
            method="GET",
            params={
                "user": user,
                "last_id": last_id,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetConversationVariablesByAppChatResponse,
                    parse_obj_as(
                        type_=GetConversationVariablesByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def get_conversation_messages_by_app_chat(
        self,
        *,
        conversation_id: str,
        user: str,
        first_id: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetConversationMessagesByAppChatResponse]:
        """
        Parameters
        ----------
        conversation_id : str
            Conversation ID

        user : str
            User identifier

        first_id : typing.Optional[str]
            First message ID

        limit : typing.Optional[int]
            Limit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetConversationMessagesByAppChatResponse]
            Successful response
        """
        _response = self._client_wrapper.httpx_client.request(
            "messages",
            method="GET",
            params={
                "conversation_id": conversation_id,
                "user": user,
                "first_id": first_id,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetConversationMessagesByAppChatResponse,
                    parse_obj_as(
                        type_=GetConversationMessagesByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def send_message_feedback_by_app_chat(
        self,
        message_id: str,
        *,
        user: str,
        rating: typing.Optional[str] = OMIT,
        content: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SendMessageFeedbackByAppChatResponse]:
        """
        End-user feedback and rating for messages, helping application developers optimize expected outputs

        Parameters
        ----------
        message_id : str
            Message ID

        user : str
            User identifier, defined by developer rules, must be unique within the application. Service API will not share conversations created by WebApp.

        rating : typing.Optional[str]
            Rating: like, dislike, or null to cancel

        content : typing.Optional[str]
            Specific feedback information for the message

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SendMessageFeedbackByAppChatResponse]
            Successful response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"messages/{jsonable_encoder(message_id)}/feedbacks",
            method="POST",
            json={
                "rating": rating,
                "user": user,
                "content": content,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SendMessageFeedbackByAppChatResponse,
                    parse_obj_as(
                        type_=SendMessageFeedbackByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def get_app_feedbacks_by_app_chat(
        self,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetAppFeedbacksByAppChatResponse]:
        """
        Get end-user feedback and likes for the application

        Parameters
        ----------
        page : typing.Optional[int]
            Page number, default: 1

        limit : typing.Optional[int]
            Number of items per page, default: 20

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetAppFeedbacksByAppChatResponse]
            Successful response
        """
        _response = self._client_wrapper.httpx_client.request(
            "app/feedbacks",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAppFeedbacksByAppChatResponse,
                    parse_obj_as(
                        type_=GetAppFeedbacksByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def get_suggested_questions_by_app_chat(
        self, message_id: str, *, user: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetSuggestedQuestionsByAppChatResponse]:
        """
        Get suggested questions for the next round

        Parameters
        ----------
        message_id : str
            Message ID

        user : str
            User identifier, defined by developer rules, must be unique within the application. Service API will not share conversations created by WebApp.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetSuggestedQuestionsByAppChatResponse]
            Successful response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"messages/{jsonable_encoder(message_id)}/suggested",
            method="GET",
            params={
                "user": user,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetSuggestedQuestionsByAppChatResponse,
                    parse_obj_as(
                        type_=GetSuggestedQuestionsByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def upload_file_by_app_chat(
        self,
        *,
        file: core.File,
        user: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[UploadedFile]:
        """
        Upload files for use when sending messages.
        Supported file types depend on application type and configuration.
        Uploaded files are only available to the current end user.

        Parameters
        ----------
        file : core.File
            See core.File for more documentation

        user : typing.Optional[str]
            User identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[UploadedFile]
            Successful response
        """
        _response = self._client_wrapper.httpx_client.request(
            "files/upload",
            method="POST",
            data={
                "user": user,
            },
            files={
                "file": file,
            },
            headers={
                # "content-type": "multipart/form-data",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UploadedFile,
                    parse_obj_as(
                        type_=UploadedFile,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def get_application_info_by_app_chat(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetApplicationInfoByAppChatResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetApplicationInfoByAppChatResponse]
            Successful response
        """
        _response = self._client_wrapper.httpx_client.request(
            "info",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetApplicationInfoByAppChatResponse,
                    parse_obj_as(
                        type_=GetApplicationInfoByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def stop_chat_response_by_app_chat(
        self, task_id: str, *, user: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[StopChatResponseByAppChatResponse]:
        """
        Only supports streaming mode

        Parameters
        ----------
        task_id : str
            Task ID, can be obtained from the streaming response chunks

        user : str
            User identifier for defining end user identity, must be consistent with the user passed in the message sending interface. API cannot access sessions created by WebApp.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[StopChatResponseByAppChatResponse]
            Successfully stopped the response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"chat-messages/{jsonable_encoder(task_id)}/stop",
            method="POST",
            json={
                "user": user,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StopChatResponseByAppChatResponse,
                    parse_obj_as(
                        type_=StopChatResponseByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def convert_audio_to_text_by_app_chat(
        self,
        *,
        file: core.File,
        user: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ConvertAudioToTextByAppChatResponse]:
        """
        Convert audio to text

        Parameters
        ----------
        file : core.File
            See core.File for more documentation

        user : typing.Optional[str]
            User identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ConvertAudioToTextByAppChatResponse]
            Successful response
        """
        _response = self._client_wrapper.httpx_client.request(
            "audio-to-text",
            method="POST",
            data={
                "user": user,
            },
            files={
                "file": file,
            },
            headers={
                # "content-type": "multipart/form-data",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ConvertAudioToTextByAppChatResponse,
                    parse_obj_as(
                        type_=ConvertAudioToTextByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    @contextlib.contextmanager
    def convert_text_to_audio_by_app_chat(
        self,
        *,
        message_id: typing.Optional[str] = OMIT,
        text: typing.Optional[str] = OMIT,
        user: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[HttpResponse[typing.Iterator[bytes]]]:
        """
        Convert text to speech

        Parameters
        ----------
        message_id : typing.Optional[str]
            Dify generated text message ID. The backend will find the corresponding content directly through the message_id to synthesize speech. If both message_id and text are provided, message_id takes precedence

        text : typing.Optional[str]
            Text content for speech generation. If message_id is not provided, this field will be used

        user : typing.Optional[str]
            User identifier, defined by developer rules, must be unique within the application. Service API will not share conversations created by WebApp.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration. You can pass in configuration such as `chunk_size`, and more to customize the request and response.

        Returns
        -------
        typing.Iterator[HttpResponse[typing.Iterator[bytes]]]
            Successful response
        """
        with self._client_wrapper.httpx_client.stream(
            "text-to-audio",
            method="POST",
            json={
                "message_id": message_id,
                "text": text,
                "user": user,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        ) as _response:

            def stream() -> HttpResponse[typing.Iterator[bytes]]:
                try:
                    if 200 <= _response.status_code < 300:
                        _chunk_size = request_options.get("chunk_size", None) if request_options is not None else None
                        return HttpResponse(
                            response=_response, data=(_chunk for _chunk in _response.iter_bytes(chunk_size=_chunk_size))
                        )
                    _response.read()
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise ApiError(
                        headers=dict(_response.headers), status_code=_response.status_code, body=_response.text
                    )
                raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

            yield stream()

    def get_application_parameters_by_app_chat(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetApplicationParametersByAppChatResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetApplicationParametersByAppChatResponse]
            Successful response
        """
        _response = self._client_wrapper.httpx_client.request(
            "parameters",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetApplicationParametersByAppChatResponse,
                    parse_obj_as(
                        type_=GetApplicationParametersByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def get_app_meta_info_by_app_chat(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetAppMetaInfoByAppChatResponse]:
        """
        Used to get tool icons

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetAppMetaInfoByAppChatResponse]
            Successful response
        """
        _response = self._client_wrapper.httpx_client.request(
            "meta",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAppMetaInfoByAppChatResponse,
                    parse_obj_as(
                        type_=GetAppMetaInfoByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def get_app_site_settings_by_app_chat(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetAppSiteSettingsByAppChatResponse]:
        """
        Used to get the WebApp settings of the application

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetAppSiteSettingsByAppChatResponse]
            Successful response
        """
        _response = self._client_wrapper.httpx_client.request(
            "site",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAppSiteSettingsByAppChatResponse,
                    parse_obj_as(
                        type_=GetAppSiteSettingsByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def get_annotations_list_by_app_chat(
        self,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetAnnotationsListByAppChatResponse]:
        """
        Get the list of annotations for the application

        Parameters
        ----------
        page : typing.Optional[int]
            Page number

        limit : typing.Optional[int]
            Items per page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetAnnotationsListByAppChatResponse]
            Successfully retrieved annotation list
        """
        _response = self._client_wrapper.httpx_client.request(
            "apps/annotations",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAnnotationsListByAppChatResponse,
                    parse_obj_as(
                        type_=GetAnnotationsListByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def create_annotation_by_app_chat(
        self, *, question: str, answer: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[CreateAnnotationByAppChatResponse]:
        """
        Create a new annotation

        Parameters
        ----------
        question : str
            Question

        answer : str
            Answer

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateAnnotationByAppChatResponse]
            Successfully created annotation
        """
        _response = self._client_wrapper.httpx_client.request(
            "apps/annotations",
            method="POST",
            json={
                "question": question,
                "answer": answer,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateAnnotationByAppChatResponse,
                    parse_obj_as(
                        type_=CreateAnnotationByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def update_annotation_by_app_chat(
        self, annotation_id: str, *, question: str, answer: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[UpdateAnnotationByAppChatResponse]:
        """
        Update a specific annotation

        Parameters
        ----------
        annotation_id : str
            Annotation ID

        question : str
            Question

        answer : str
            Answer

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[UpdateAnnotationByAppChatResponse]
            Successfully updated annotation
        """
        _response = self._client_wrapper.httpx_client.request(
            f"apps/annotations/{jsonable_encoder(annotation_id)}",
            method="PUT",
            json={
                "question": question,
                "answer": answer,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpdateAnnotationByAppChatResponse,
                    parse_obj_as(
                        type_=UpdateAnnotationByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def delete_annotation_by_app_chat(
        self, annotation_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DeleteAnnotationByAppChatResponse]:
        """
        Delete a specific annotation

        Parameters
        ----------
        annotation_id : str
            Annotation ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeleteAnnotationByAppChatResponse]
            Successfully deleted annotation
        """
        _response = self._client_wrapper.httpx_client.request(
            f"apps/annotations/{jsonable_encoder(annotation_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteAnnotationByAppChatResponse,
                    parse_obj_as(
                        type_=DeleteAnnotationByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def configure_annotation_reply_by_app_chat(
        self,
        action: ConfigureAnnotationReplyByAppChatRequestAction,
        *,
        embedding_provider_name: typing.Optional[str] = OMIT,
        embedding_model_name: typing.Optional[str] = OMIT,
        score_threshold: typing.Optional[float] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ConfigureAnnotationReplyByAppChatResponse]:
        """
        Enable or disable annotation reply functionality

        Parameters
        ----------
        action : ConfigureAnnotationReplyByAppChatRequestAction
            Action, can only be 'enable' or 'disable'

        embedding_provider_name : typing.Optional[str]
            Specified embedding model provider, must be configured in the system first, corresponds to the provider field

        embedding_model_name : typing.Optional[str]
            Specified embedding model, corresponds to the model field

        score_threshold : typing.Optional[float]
            Similarity score threshold, when similarity is greater than this threshold, the system will automatically reply, otherwise it will not reply

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ConfigureAnnotationReplyByAppChatResponse]
            Successfully enabled or disabled annotation reply
        """
        _response = self._client_wrapper.httpx_client.request(
            f"apps/annotation-reply/{jsonable_encoder(action)}",
            method="POST",
            json={
                "embedding_provider_name": embedding_provider_name,
                "embedding_model_name": embedding_model_name,
                "score_threshold": score_threshold,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ConfigureAnnotationReplyByAppChatResponse,
                    parse_obj_as(
                        type_=ConfigureAnnotationReplyByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def get_annotation_reply_status_by_app_chat(
        self,
        action: GetAnnotationReplyStatusByAppChatRequestAction,
        job_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetAnnotationReplyStatusByAppChatResponse]:
        """
        Query the status of annotation reply initialization task

        Parameters
        ----------
        action : GetAnnotationReplyStatusByAppChatRequestAction
            Action, can only be 'enable' or 'disable', and must be consistent with the action in the annotation reply initialization interface

        job_id : str
            Job ID, returned from the annotation reply initialization interface

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetAnnotationReplyStatusByAppChatResponse]
            Successfully retrieved job status
        """
        _response = self._client_wrapper.httpx_client.request(
            f"apps/annotation-reply/{jsonable_encoder(action)}/status/{jsonable_encoder(job_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAnnotationReplyStatusByAppChatResponse,
                    parse_obj_as(
                        type_=GetAnnotationReplyStatusByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)


class AsyncRawChatClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    @contextlib.asynccontextmanager
    async def send_chat_message_by_app_chat(
        self,
        *,
        query: str,
        inputs: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        response_mode: typing.Optional[SendChatMessageByAppChatRequestResponseMode] = OMIT,
        user: typing.Optional[str] = OMIT,
        conversation_id: typing.Optional[str] = OMIT,
        files: typing.Optional[typing.Sequence[SendChatMessageByAppChatRequestFilesItem]] = OMIT,
        auto_generate_name: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[AsyncHttpResponse[typing.AsyncIterator[ChunkChatCompletionResponse]]]:
        """
        Create conversation message

        Parameters
        ----------
        query : str
            User input/question content

        inputs : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]
            Allows passing values for variables defined by the App. The inputs parameter contains multiple key/value pairs, where each key corresponds to a specific variable and each value is the value for that variable. Default {}

        response_mode : typing.Optional[SendChatMessageByAppChatRequestResponseMode]
            Response mode:
            - streaming: Streaming mode (recommended), implements typewriter-like output based on SSE
            - blocking: Blocking mode, returns result after execution is complete (request may be interrupted if the process is too long)
            Note: Blocking mode is not allowed in Agent mode

        user : typing.Optional[str]
            User identifier for defining end user identity, facilitating retrieval and statistics. Defined by developer rules, must be unique within the application. Service API will not share conversations created by WebApp.

        conversation_id : typing.Optional[str]
            (Optional) Conversation ID. Required when continuing a conversation based on previous chat history, must pass the conversation_id from previous messages

        files : typing.Optional[typing.Sequence[SendChatMessageByAppChatRequestFilesItem]]
            Uploaded files

        auto_generate_name : typing.Optional[bool]
            (Optional) Whether to automatically generate title, default is true. If set to false, you can call the conversation rename interface and set auto_generate to true to generate a title asynchronously.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.AsyncIterator[AsyncHttpResponse[typing.AsyncIterator[ChunkChatCompletionResponse]]]
            Successful response
        """
        async with self._client_wrapper.httpx_client.stream(
            "chat-messages",
            method="POST",
            json={
                "query": query,
                "inputs": inputs,
                "response_mode": response_mode,
                "user": user,
                "conversation_id": conversation_id,
                "files": convert_and_respect_annotation_metadata(
                    object_=files,
                    annotation=typing.Sequence[SendChatMessageByAppChatRequestFilesItem],
                    direction="write",
                ),
                "auto_generate_name": auto_generate_name,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        ) as _response:

            async def stream() -> AsyncHttpResponse[typing.AsyncIterator[ChunkChatCompletionResponse]]:
                try:
                    if 200 <= _response.status_code < 300:

                        async def _iter():
                            _event_source = httpx_sse.EventSource(_response)
                            async for _sse in _event_source.aiter_sse():
                                if _sse.data == None:
                                    return
                                try:
                                    yield _sse.data
                                except Exception:
                                    pass
                            return

                        return AsyncHttpResponse(response=_response, data=_iter())
                    await _response.aread()
                    if _response.status_code == 400:
                        raise BadRequestError(
                            typing.cast(
                                Error,
                                parse_obj_as(
                                    type_=Error,  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    if _response.status_code == 404:
                        raise NotFoundError(
                            typing.cast(
                                typing.Optional[typing.Any],
                                parse_obj_as(
                                    type_=typing.Optional[typing.Any],  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    if _response.status_code == 500:
                        raise InternalServerError(
                            typing.cast(
                                Error,
                                parse_obj_as(
                                    type_=Error,  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise ApiError(
                        headers=dict(_response.headers), status_code=_response.status_code, body=_response.text
                    )
                raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

            yield await stream()

    async def get_conversation_list_by_app_chat(
        self,
        *,
        user: str,
        last_id: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        sort_by: typing.Optional[GetConversationListByAppChatRequestSortBy] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetConversationListByAppChatResponse]:
        """
        Get conversation list for current user

        Parameters
        ----------
        user : str
            User identifier

        last_id : typing.Optional[str]
            ID of the last record on current page

        limit : typing.Optional[int]
            Records per page

        sort_by : typing.Optional[GetConversationListByAppChatRequestSortBy]
            Sort field

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetConversationListByAppChatResponse]
            Successful response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "conversations",
            method="GET",
            params={
                "user": user,
                "last_id": last_id,
                "limit": limit,
                "sort_by": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetConversationListByAppChatResponse,
                    parse_obj_as(
                        type_=GetConversationListByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def delete_conversation_by_app_chat(
        self, conversation_id: str, *, user: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[None]:
        """
        Parameters
        ----------
        conversation_id : str
            Conversation ID

        user : str
            User identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[None]
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"conversations/{jsonable_encoder(conversation_id)}",
            method="DELETE",
            json={
                "user": user,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return AsyncHttpResponse(response=_response, data=None)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def rename_conversation_by_app_chat(
        self,
        conversation_id: str,
        *,
        user: str,
        name: typing.Optional[str] = OMIT,
        auto_generate: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[Conversation]:
        """
        Parameters
        ----------
        conversation_id : str

        user : str
            User identifier

        name : typing.Optional[str]
            New name

        auto_generate : typing.Optional[bool]
            Whether to automatically generate

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[Conversation]
            Successful response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"conversations/{jsonable_encoder(conversation_id)}/name",
            method="POST",
            json={
                "name": name,
                "auto_generate": auto_generate,
                "user": user,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    Conversation,
                    parse_obj_as(
                        type_=Conversation,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def get_conversation_variables_by_app_chat(
        self,
        conversation_id: str,
        *,
        user: str,
        last_id: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetConversationVariablesByAppChatResponse]:
        """
        Retrieve variables from a specific conversation. This endpoint is useful for extracting structured data captured during conversations.

        Parameters
        ----------
        conversation_id : str
            ID of the conversation to retrieve variables from

        user : str
            User identifier, defined by developer rules, must be unique within the application. Service API will not share conversations created by WebApp.

        last_id : typing.Optional[str]
            (Optional) ID of the last record on the current page, default null

        limit : typing.Optional[int]
            (Optional) Number of records to return per request, default 20, max 100, min 1

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetConversationVariablesByAppChatResponse]
            Successfully retrieved variables
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"conversations/{jsonable_encoder(conversation_id)}/variables",
            method="GET",
            params={
                "user": user,
                "last_id": last_id,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetConversationVariablesByAppChatResponse,
                    parse_obj_as(
                        type_=GetConversationVariablesByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def get_conversation_messages_by_app_chat(
        self,
        *,
        conversation_id: str,
        user: str,
        first_id: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetConversationMessagesByAppChatResponse]:
        """
        Parameters
        ----------
        conversation_id : str
            Conversation ID

        user : str
            User identifier

        first_id : typing.Optional[str]
            First message ID

        limit : typing.Optional[int]
            Limit

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetConversationMessagesByAppChatResponse]
            Successful response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "messages",
            method="GET",
            params={
                "conversation_id": conversation_id,
                "user": user,
                "first_id": first_id,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetConversationMessagesByAppChatResponse,
                    parse_obj_as(
                        type_=GetConversationMessagesByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def send_message_feedback_by_app_chat(
        self,
        message_id: str,
        *,
        user: str,
        rating: typing.Optional[str] = OMIT,
        content: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SendMessageFeedbackByAppChatResponse]:
        """
        End-user feedback and rating for messages, helping application developers optimize expected outputs

        Parameters
        ----------
        message_id : str
            Message ID

        user : str
            User identifier, defined by developer rules, must be unique within the application. Service API will not share conversations created by WebApp.

        rating : typing.Optional[str]
            Rating: like, dislike, or null to cancel

        content : typing.Optional[str]
            Specific feedback information for the message

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SendMessageFeedbackByAppChatResponse]
            Successful response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"messages/{jsonable_encoder(message_id)}/feedbacks",
            method="POST",
            json={
                "rating": rating,
                "user": user,
                "content": content,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SendMessageFeedbackByAppChatResponse,
                    parse_obj_as(
                        type_=SendMessageFeedbackByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def get_app_feedbacks_by_app_chat(
        self,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetAppFeedbacksByAppChatResponse]:
        """
        Get end-user feedback and likes for the application

        Parameters
        ----------
        page : typing.Optional[int]
            Page number, default: 1

        limit : typing.Optional[int]
            Number of items per page, default: 20

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetAppFeedbacksByAppChatResponse]
            Successful response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "app/feedbacks",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAppFeedbacksByAppChatResponse,
                    parse_obj_as(
                        type_=GetAppFeedbacksByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def get_suggested_questions_by_app_chat(
        self, message_id: str, *, user: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetSuggestedQuestionsByAppChatResponse]:
        """
        Get suggested questions for the next round

        Parameters
        ----------
        message_id : str
            Message ID

        user : str
            User identifier, defined by developer rules, must be unique within the application. Service API will not share conversations created by WebApp.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetSuggestedQuestionsByAppChatResponse]
            Successful response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"messages/{jsonable_encoder(message_id)}/suggested",
            method="GET",
            params={
                "user": user,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetSuggestedQuestionsByAppChatResponse,
                    parse_obj_as(
                        type_=GetSuggestedQuestionsByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def upload_file_by_app_chat(
        self,
        *,
        file: core.File,
        user: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[UploadedFile]:
        """
        Upload files for use when sending messages.
        Supported file types depend on application type and configuration.
        Uploaded files are only available to the current end user.

        Parameters
        ----------
        file : core.File
            See core.File for more documentation

        user : typing.Optional[str]
            User identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[UploadedFile]
            Successful response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "files/upload",
            method="POST",
            data={
                "user": user,
            },
            files={
                "file": file,
            },
            headers={
                # "content-type": "multipart/form-data",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UploadedFile,
                    parse_obj_as(
                        type_=UploadedFile,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def get_application_info_by_app_chat(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetApplicationInfoByAppChatResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetApplicationInfoByAppChatResponse]
            Successful response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "info",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetApplicationInfoByAppChatResponse,
                    parse_obj_as(
                        type_=GetApplicationInfoByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def stop_chat_response_by_app_chat(
        self, task_id: str, *, user: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[StopChatResponseByAppChatResponse]:
        """
        Only supports streaming mode

        Parameters
        ----------
        task_id : str
            Task ID, can be obtained from the streaming response chunks

        user : str
            User identifier for defining end user identity, must be consistent with the user passed in the message sending interface. API cannot access sessions created by WebApp.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[StopChatResponseByAppChatResponse]
            Successfully stopped the response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"chat-messages/{jsonable_encoder(task_id)}/stop",
            method="POST",
            json={
                "user": user,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StopChatResponseByAppChatResponse,
                    parse_obj_as(
                        type_=StopChatResponseByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def convert_audio_to_text_by_app_chat(
        self,
        *,
        file: core.File,
        user: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ConvertAudioToTextByAppChatResponse]:
        """
        Convert audio to text

        Parameters
        ----------
        file : core.File
            See core.File for more documentation

        user : typing.Optional[str]
            User identifier

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ConvertAudioToTextByAppChatResponse]
            Successful response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "audio-to-text",
            method="POST",
            data={
                "user": user,
            },
            files={
                "file": file,
            },
            headers={
                # "content-type": "multipart/form-data",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ConvertAudioToTextByAppChatResponse,
                    parse_obj_as(
                        type_=ConvertAudioToTextByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    @contextlib.asynccontextmanager
    async def convert_text_to_audio_by_app_chat(
        self,
        *,
        message_id: typing.Optional[str] = OMIT,
        text: typing.Optional[str] = OMIT,
        user: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[AsyncHttpResponse[typing.AsyncIterator[bytes]]]:
        """
        Convert text to speech

        Parameters
        ----------
        message_id : typing.Optional[str]
            Dify generated text message ID. The backend will find the corresponding content directly through the message_id to synthesize speech. If both message_id and text are provided, message_id takes precedence

        text : typing.Optional[str]
            Text content for speech generation. If message_id is not provided, this field will be used

        user : typing.Optional[str]
            User identifier, defined by developer rules, must be unique within the application. Service API will not share conversations created by WebApp.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration. You can pass in configuration such as `chunk_size`, and more to customize the request and response.

        Returns
        -------
        typing.AsyncIterator[AsyncHttpResponse[typing.AsyncIterator[bytes]]]
            Successful response
        """
        async with self._client_wrapper.httpx_client.stream(
            "text-to-audio",
            method="POST",
            json={
                "message_id": message_id,
                "text": text,
                "user": user,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        ) as _response:

            async def stream() -> AsyncHttpResponse[typing.AsyncIterator[bytes]]:
                try:
                    if 200 <= _response.status_code < 300:
                        _chunk_size = request_options.get("chunk_size", None) if request_options is not None else None
                        return AsyncHttpResponse(
                            response=_response,
                            data=(_chunk async for _chunk in _response.aiter_bytes(chunk_size=_chunk_size)),
                        )
                    await _response.aread()
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise ApiError(
                        headers=dict(_response.headers), status_code=_response.status_code, body=_response.text
                    )
                raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

            yield await stream()

    async def get_application_parameters_by_app_chat(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetApplicationParametersByAppChatResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetApplicationParametersByAppChatResponse]
            Successful response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "parameters",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetApplicationParametersByAppChatResponse,
                    parse_obj_as(
                        type_=GetApplicationParametersByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def get_app_meta_info_by_app_chat(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetAppMetaInfoByAppChatResponse]:
        """
        Used to get tool icons

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetAppMetaInfoByAppChatResponse]
            Successful response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "meta",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAppMetaInfoByAppChatResponse,
                    parse_obj_as(
                        type_=GetAppMetaInfoByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def get_app_site_settings_by_app_chat(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetAppSiteSettingsByAppChatResponse]:
        """
        Used to get the WebApp settings of the application

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetAppSiteSettingsByAppChatResponse]
            Successful response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "site",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAppSiteSettingsByAppChatResponse,
                    parse_obj_as(
                        type_=GetAppSiteSettingsByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def get_annotations_list_by_app_chat(
        self,
        *,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetAnnotationsListByAppChatResponse]:
        """
        Get the list of annotations for the application

        Parameters
        ----------
        page : typing.Optional[int]
            Page number

        limit : typing.Optional[int]
            Items per page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetAnnotationsListByAppChatResponse]
            Successfully retrieved annotation list
        """
        _response = await self._client_wrapper.httpx_client.request(
            "apps/annotations",
            method="GET",
            params={
                "page": page,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAnnotationsListByAppChatResponse,
                    parse_obj_as(
                        type_=GetAnnotationsListByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def create_annotation_by_app_chat(
        self, *, question: str, answer: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[CreateAnnotationByAppChatResponse]:
        """
        Create a new annotation

        Parameters
        ----------
        question : str
            Question

        answer : str
            Answer

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateAnnotationByAppChatResponse]
            Successfully created annotation
        """
        _response = await self._client_wrapper.httpx_client.request(
            "apps/annotations",
            method="POST",
            json={
                "question": question,
                "answer": answer,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateAnnotationByAppChatResponse,
                    parse_obj_as(
                        type_=CreateAnnotationByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def update_annotation_by_app_chat(
        self, annotation_id: str, *, question: str, answer: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[UpdateAnnotationByAppChatResponse]:
        """
        Update a specific annotation

        Parameters
        ----------
        annotation_id : str
            Annotation ID

        question : str
            Question

        answer : str
            Answer

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[UpdateAnnotationByAppChatResponse]
            Successfully updated annotation
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"apps/annotations/{jsonable_encoder(annotation_id)}",
            method="PUT",
            json={
                "question": question,
                "answer": answer,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpdateAnnotationByAppChatResponse,
                    parse_obj_as(
                        type_=UpdateAnnotationByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def delete_annotation_by_app_chat(
        self, annotation_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DeleteAnnotationByAppChatResponse]:
        """
        Delete a specific annotation

        Parameters
        ----------
        annotation_id : str
            Annotation ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeleteAnnotationByAppChatResponse]
            Successfully deleted annotation
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"apps/annotations/{jsonable_encoder(annotation_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteAnnotationByAppChatResponse,
                    parse_obj_as(
                        type_=DeleteAnnotationByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def configure_annotation_reply_by_app_chat(
        self,
        action: ConfigureAnnotationReplyByAppChatRequestAction,
        *,
        embedding_provider_name: typing.Optional[str] = OMIT,
        embedding_model_name: typing.Optional[str] = OMIT,
        score_threshold: typing.Optional[float] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ConfigureAnnotationReplyByAppChatResponse]:
        """
        Enable or disable annotation reply functionality

        Parameters
        ----------
        action : ConfigureAnnotationReplyByAppChatRequestAction
            Action, can only be 'enable' or 'disable'

        embedding_provider_name : typing.Optional[str]
            Specified embedding model provider, must be configured in the system first, corresponds to the provider field

        embedding_model_name : typing.Optional[str]
            Specified embedding model, corresponds to the model field

        score_threshold : typing.Optional[float]
            Similarity score threshold, when similarity is greater than this threshold, the system will automatically reply, otherwise it will not reply

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ConfigureAnnotationReplyByAppChatResponse]
            Successfully enabled or disabled annotation reply
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"apps/annotation-reply/{jsonable_encoder(action)}",
            method="POST",
            json={
                "embedding_provider_name": embedding_provider_name,
                "embedding_model_name": embedding_model_name,
                "score_threshold": score_threshold,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ConfigureAnnotationReplyByAppChatResponse,
                    parse_obj_as(
                        type_=ConfigureAnnotationReplyByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def get_annotation_reply_status_by_app_chat(
        self,
        action: GetAnnotationReplyStatusByAppChatRequestAction,
        job_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetAnnotationReplyStatusByAppChatResponse]:
        """
        Query the status of annotation reply initialization task

        Parameters
        ----------
        action : GetAnnotationReplyStatusByAppChatRequestAction
            Action, can only be 'enable' or 'disable', and must be consistent with the action in the annotation reply initialization interface

        job_id : str
            Job ID, returned from the annotation reply initialization interface

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetAnnotationReplyStatusByAppChatResponse]
            Successfully retrieved job status
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"apps/annotation-reply/{jsonable_encoder(action)}/status/{jsonable_encoder(job_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAnnotationReplyStatusByAppChatResponse,
                    parse_obj_as(
                        type_=GetAnnotationReplyStatusByAppChatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)
