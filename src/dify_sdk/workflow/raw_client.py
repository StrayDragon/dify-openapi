# This file was auto-generated by Fern from our API Definition.

import contextlib
import json
import typing
from json.decoder import JSONDecodeError

import httpx_sse
from .. import core
from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from .errors.bad_request_error import BadRequestError
from .errors.content_too_large_error import ContentTooLargeError
from .errors.forbidden_error import ForbiddenError
from .errors.internal_server_error import InternalServerError
from .errors.not_found_error import NotFoundError
from .errors.service_unavailable_error import ServiceUnavailableError
from .errors.unauthorized_error import UnauthorizedError
from .errors.unsupported_media_type_error import UnsupportedMediaTypeError
from .types.chunk_workflow_message import ChunkWorkflowMessage
from .types.error import Error
from .types.get_app_info_response import GetAppInfoResponse
from .types.get_app_parameters_response import GetAppParametersResponse
from .types.get_app_site_response import GetAppSiteResponse
from .types.get_workflow_execution_status_response import GetWorkflowExecutionStatusResponse
from .types.get_workflow_logs_request_status import GetWorkflowLogsRequestStatus
from .types.get_workflow_logs_response import GetWorkflowLogsResponse
from .types.run_specific_workflow_request_response_mode import RunSpecificWorkflowRequestResponseMode
from .types.run_workflow_request_response_mode import RunWorkflowRequestResponseMode
from .types.stop_workflow_response import StopWorkflowResponse
from .types.upload_file_response import UploadFileResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawWorkflowClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    @contextlib.contextmanager
    def run_workflow(
        self,
        *,
        inputs: typing.Dict[str, typing.Optional[typing.Any]],
        response_mode: RunWorkflowRequestResponseMode,
        user: str,
        files: typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]] = OMIT,
        trace_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[HttpResponse[typing.Iterator[ChunkWorkflowMessage]]]:
        """
        Execute a workflow. Cannot be executed if there is no published workflow.

        Parameters
        ----------
        inputs : typing.Dict[str, typing.Optional[typing.Any]]
            Allows passing values for variables defined in the App.
            The inputs parameter contains multiple key/value pairs, where each key corresponds to a specific variable and each value is the specific value for that variable. Variables can be of file list type.
            File list type variables are suitable for passing files combined with text understanding to answer questions, only available when the model supports parsing capabilities for that type of file. If the variable is a file list type, the value corresponding to the variable should be in list format, where each element should include the following:
              - `type` (string) Supported types:
                - `document` Specific types include: 'TXT', 'MD', 'MARKDOWN', 'PDF', 'HTML', 'XLSX', 'XLS', 'DOCX', 'CSV', 'EML', 'MSG', 'PPTX', 'PPT', 'XML', 'EPUB'
                - `image` Specific types include: 'JPG', 'JPEG', 'PNG', 'GIF', 'WEBP', 'SVG'
                - `audio` Specific types include: 'MP3', 'M4A', 'WAV', 'WEBM', 'AMR'
                - `video` Specific types include: 'MP4', 'MOV', 'MPEG', 'MPGA'
                - `custom` Specific types include: other file types
              - `transfer_method` (string) Transfer method, `remote_url` image address / `local_file` uploaded file
              - `url` (string) Image address (only when the transfer method is `remote_url`)
              - `upload_file_id` (string) Upload file ID (only when the transfer method is `local_file`)

        response_mode : RunWorkflowRequestResponseMode
            Response mode, supports:
            - `streaming` Streaming mode (recommended). Implements streaming return similar to typewriter output based on SSE (Server-Sent Events).
            - `blocking` Blocking mode, waits for execution to complete before returning results. (Requests may be interrupted if the process is lengthy).
            Due to Cloudflare limitations, requests will be interrupted after 100 seconds of timeout with no response.

        user : str
            User identifier, used to define the identity of the end user, for easy retrieval and statistics.
            Rules defined by the developer, the user identifier must be unique within the application. API cannot access sessions created by WebApp.

        files : typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]]
            Optional file list

        trace_id : typing.Optional[str]
            Tracing ID. Suitable for integrating with existing trace components in business systems to achieve end-to-end distributed tracing. If not specified, the system will automatically generate a `trace_id`. Supports the following three transmission methods, with priorities as follows:
            1. Header: Recommended to pass through HTTP Header `X-Trace-Id`, highest priority.
            2. Query parameter: Pass through URL query parameter `trace_id`.
            3. Request Body: Pass through request body field `trace_id` (this field).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.Iterator[HttpResponse[typing.Iterator[ChunkWorkflowMessage]]]
            Successful response
        """
        with self._client_wrapper.httpx_client.stream(
            "workflows/run",
            method="POST",
            json={
                "inputs": inputs,
                "response_mode": response_mode,
                "user": user,
                "files": files,
                "trace_id": trace_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        ) as _response:

            def stream() -> HttpResponse[typing.Iterator[ChunkWorkflowMessage]]:
                try:
                    if 200 <= _response.status_code < 300:

                        def _iter():
                            for _text in _response.iter_lines():
                                try:
                                    _text = _text.removeprefix("data: ")

                                    if len(_text) == 0:
                                        continue
                                    yield typing.cast(
                                        ChunkWorkflowMessage,
                                        parse_obj_as(
                                            type_=ChunkWorkflowMessage,  # type: ignore
                                            object_=json.loads(_text),
                                        ),
                                    )
                                except Exception:
                                    pass
                            return

                        return HttpResponse(response=_response, data=_iter())
                    _response.read()
                    if _response.status_code == 400:
                        raise BadRequestError(
                            typing.cast(
                                typing.Optional[typing.Any],
                                parse_obj_as(
                                    type_=typing.Optional[typing.Any],  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    if _response.status_code == 404:
                        raise NotFoundError(
                            typing.cast(
                                typing.Optional[typing.Any],
                                parse_obj_as(
                                    type_=typing.Optional[typing.Any],  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    if _response.status_code == 500:
                        raise InternalServerError(
                            typing.cast(
                                Error,
                                parse_obj_as(
                                    type_=Error,  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise ApiError(
                        headers=dict(_response.headers), status_code=_response.status_code, body=_response.text
                    )
                raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

            yield stream()

    @contextlib.contextmanager
    def run_specific_workflow(
        self,
        workflow_id: str,
        *,
        inputs: typing.Dict[str, typing.Optional[typing.Any]],
        response_mode: RunSpecificWorkflowRequestResponseMode,
        user: str,
        files: typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]] = OMIT,
        trace_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[HttpResponse[typing.Iterator[ChunkWorkflowMessage]]]:
        """
        Execute a specific version of the workflow, specifying the workflow ID through the path parameter

        Parameters
        ----------
        workflow_id : str
            Workflow ID, used to specify a specific version of the workflow. How to obtain: You can query the specific version workflow ID in the version history.

        inputs : typing.Dict[str, typing.Optional[typing.Any]]
            Allows passing values for variables defined in the App.
            The inputs parameter contains multiple key/value pairs, where each key corresponds to a specific variable and each value is the specific value for that variable. Variables can be of file list type.
            File list type variables are suitable for passing files combined with text understanding to answer questions, only available when the model supports parsing capabilities for that type of file. If the variable is a file list type, the value corresponding to the variable should be in list format, where each element should include the following:
              - `type` (string) Supported types:
                - `document` Specific types include: 'TXT', 'MD', 'MARKDOWN', 'PDF', 'HTML', 'XLSX', 'XLS', 'DOCX', 'CSV', 'EML', 'MSG', 'PPTX', 'PPT', 'XML', 'EPUB'
                - `image` Specific types include: 'JPG', 'JPEG', 'PNG', 'GIF', 'WEBP', 'SVG'
                - `audio` Specific types include: 'MP3', 'M4A', 'WAV', 'WEBM', 'AMR'
                - `video` Specific types include: 'MP4', 'MOV', 'MPEG', 'MPGA'
                - `custom` Specific types include: other file types
              - `transfer_method` (string) Transfer method, `remote_url` image address / `local_file` uploaded file
              - `url` (string) Image address (only when the transfer method is `remote_url`)
              - `upload_file_id` (string) Upload file ID (only when the transfer method is `local_file`)

        response_mode : RunSpecificWorkflowRequestResponseMode
            Response mode, supports:
            - `streaming` Streaming mode (recommended). Implements streaming return similar to typewriter output based on SSE (Server-Sent Events).
            - `blocking` Blocking mode, waits for execution to complete before returning results. (Requests may be interrupted if the process is lengthy).
            Due to Cloudflare limitations, requests will be interrupted after 100 seconds of timeout with no response.

        user : str
            User identifier, used to define the identity of the end user, for easy retrieval and statistics.
            Rules defined by the developer, the user identifier must be unique within the application. API cannot access sessions created by WebApp.

        files : typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]]
            Optional file list

        trace_id : typing.Optional[str]
            Tracing ID. Suitable for integrating with existing trace components in business systems to achieve end-to-end distributed tracing. If not specified, the system will automatically generate a `trace_id`. Supports the following three transmission methods, with priorities as follows:
            1. Header: Recommended to pass through HTTP Header `X-Trace-Id`, highest priority.
            2. Query parameter: Pass through URL query parameter `trace_id`.
            3. Request Body: Pass through request body field `trace_id` (this field).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.Iterator[HttpResponse[typing.Iterator[ChunkWorkflowMessage]]]
            Successful response
        """
        with self._client_wrapper.httpx_client.stream(
            f"workflows/{jsonable_encoder(workflow_id)}/run",
            method="POST",
            json={
                "inputs": inputs,
                "response_mode": response_mode,
                "user": user,
                "files": files,
                "trace_id": trace_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        ) as _response:

            def stream() -> HttpResponse[typing.Iterator[ChunkWorkflowMessage]]:
                try:
                    if 200 <= _response.status_code < 300:

                        def _iter():
                            _event_source = httpx_sse.EventSource(_response)
                            for _sse in _event_source.iter_sse():
                                if _sse.data == None:
                                    return
                                try:
                                    yield _sse.data
                                except Exception:
                                    pass
                            return

                        return HttpResponse(response=_response, data=_iter())
                    _response.read()
                    if _response.status_code == 400:
                        raise BadRequestError(
                            typing.cast(
                                typing.Optional[typing.Any],
                                parse_obj_as(
                                    type_=typing.Optional[typing.Any],  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    if _response.status_code == 404:
                        raise NotFoundError(
                            typing.cast(
                                typing.Optional[typing.Any],
                                parse_obj_as(
                                    type_=typing.Optional[typing.Any],  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    if _response.status_code == 500:
                        raise InternalServerError(
                            typing.cast(
                                Error,
                                parse_obj_as(
                                    type_=Error,  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise ApiError(
                        headers=dict(_response.headers), status_code=_response.status_code, body=_response.text
                    )
                raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

            yield stream()

    def get_workflow_execution_status(
        self, workflow_run_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetWorkflowExecutionStatusResponse]:
        """
        Get the current execution result of a workflow task based on the workflow execution ID

        Parameters
        ----------
        workflow_run_id : str
            Workflow run ID, can be obtained from the streaming response chunks

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetWorkflowExecutionStatusResponse]
            Successfully retrieved workflow execution status
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/run/{jsonable_encoder(workflow_run_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetWorkflowExecutionStatusResponse,
                    parse_obj_as(
                        type_=GetWorkflowExecutionStatusResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def stop_workflow(
        self, task_id: str, *, user: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[StopWorkflowResponse]:
        """
        Only supports streaming mode

        Parameters
        ----------
        task_id : str
            Task ID, can be obtained from the streaming response chunks

        user : str
            User identifier, must be consistent with the user passed in the message sending interface. API cannot access sessions created by WebApp.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[StopWorkflowResponse]
            Successfully stopped the response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"workflows/tasks/{jsonable_encoder(task_id)}/stop",
            method="POST",
            json={
                "user": user,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StopWorkflowResponse,
                    parse_obj_as(
                        type_=StopWorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def get_workflow_logs(
        self,
        *,
        keyword: typing.Optional[str] = None,
        status: typing.Optional[GetWorkflowLogsRequestStatus] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        created_by_end_user_session_id: typing.Optional[str] = None,
        created_by_account: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[GetWorkflowLogsResponse]:
        """
        Return workflow logs in reverse order

        Parameters
        ----------
        keyword : typing.Optional[str]
            Keyword

        status : typing.Optional[GetWorkflowLogsRequestStatus]
            Execution status: succeeded/failed/stopped

        page : typing.Optional[int]
            Current page number, default 1

        limit : typing.Optional[int]
            Items per page, default 20

        created_by_end_user_session_id : typing.Optional[str]
            Created by which end user session, e.g., `abc-123`

        created_by_account : typing.Optional[str]
            Created by which email account, e.g., lizb@test.com

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetWorkflowLogsResponse]
            Successfully retrieved workflow logs
        """
        _response = self._client_wrapper.httpx_client.request(
            "workflows/logs",
            method="GET",
            params={
                "keyword": keyword,
                "status": status,
                "page": page,
                "limit": limit,
                "created_by_end_user_session_id": created_by_end_user_session_id,
                "created_by_account": created_by_account,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetWorkflowLogsResponse,
                    parse_obj_as(
                        type_=GetWorkflowLogsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def upload_file(
        self, *, file: core.File, user: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[UploadFileResponse]:
        """
        Upload a file to use when sending messages, enabling multimodal understanding. Supports any format supported by your workflow. Uploaded files are only available to the current end user.

        Parameters
        ----------
        file : core.File
            See core.File for more documentation

        user : str
            User identifier, used to define the identity of the end user, must be consistent with the user passed in the message sending interface

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[UploadFileResponse]
            File uploaded successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            "files/upload",
            method="POST",
            data={
                "user": user,
            },
            files={
                "file": file,
            },
            headers={
                # "content-type": "multipart/form-data",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UploadFileResponse,
                    parse_obj_as(
                        type_=UploadFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    @contextlib.contextmanager
    def preview_file(
        self,
        file_id: str,
        *,
        as_attachment: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[HttpResponse[typing.Iterator[bytes]]]:
        """
        Preview or download uploaded files. This endpoint allows you to access files previously uploaded through the file upload API. Files can only be accessed within the message scope belonging to the requesting application.

        Parameters
        ----------
        file_id : str
            Unique identifier of the file to preview, obtained from the file upload API response

        as_attachment : typing.Optional[bool]
            Whether to force the file to be downloaded as an attachment. Defaults to `false` (preview in browser)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration. You can pass in configuration such as `chunk_size`, and more to customize the request and response.

        Returns
        -------
        typing.Iterator[HttpResponse[typing.Iterator[bytes]]]
            Successfully retrieved file content
        """
        with self._client_wrapper.httpx_client.stream(
            f"files/{jsonable_encoder(file_id)}/preview",
            method="GET",
            params={
                "as_attachment": as_attachment,
            },
            request_options=request_options,
        ) as _response:

            def stream() -> HttpResponse[typing.Iterator[bytes]]:
                try:
                    if 200 <= _response.status_code < 300:
                        _chunk_size = request_options.get("chunk_size", None) if request_options is not None else None
                        return HttpResponse(
                            response=_response, data=(_chunk for _chunk in _response.iter_bytes(chunk_size=_chunk_size))
                        )
                    _response.read()
                    if _response.status_code == 400:
                        raise BadRequestError(
                            typing.cast(
                                typing.Optional[typing.Any],
                                parse_obj_as(
                                    type_=typing.Optional[typing.Any],  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    if _response.status_code == 403:
                        raise ForbiddenError(
                            typing.cast(
                                typing.Optional[typing.Any],
                                parse_obj_as(
                                    type_=typing.Optional[typing.Any],  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    if _response.status_code == 404:
                        raise NotFoundError(
                            typing.cast(
                                typing.Optional[typing.Any],
                                parse_obj_as(
                                    type_=typing.Optional[typing.Any],  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    if _response.status_code == 500:
                        raise InternalServerError(
                            typing.cast(
                                Error,
                                parse_obj_as(
                                    type_=Error,  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise ApiError(
                        headers=dict(_response.headers), status_code=_response.status_code, body=_response.text
                    )
                raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

            yield stream()

    def get_app_info(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetAppInfoResponse]:
        """
        Used to get basic information about the application

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetAppInfoResponse]
            Successfully retrieved application information
        """
        _response = self._client_wrapper.httpx_client.request(
            "info",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAppInfoResponse,
                    parse_obj_as(
                        type_=GetAppInfoResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def get_app_parameters(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetAppParametersResponse]:
        """
        Used at the beginning of page entry to get feature switches, input parameter names, types, and default values

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetAppParametersResponse]
            Successfully retrieved application parameters
        """
        _response = self._client_wrapper.httpx_client.request(
            "parameters",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAppParametersResponse,
                    parse_obj_as(
                        type_=GetAppParametersResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    def get_app_site(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetAppSiteResponse]:
        """
        Used to get the WebApp settings of the application

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetAppSiteResponse]
            Successfully retrieved application WebApp settings
        """
        _response = self._client_wrapper.httpx_client.request(
            "site",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAppSiteResponse,
                    parse_obj_as(
                        type_=GetAppSiteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)


class AsyncRawWorkflowClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    @contextlib.asynccontextmanager
    async def run_workflow(
        self,
        *,
        inputs: typing.Dict[str, typing.Optional[typing.Any]],
        response_mode: RunWorkflowRequestResponseMode,
        user: str,
        files: typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]] = OMIT,
        trace_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[AsyncHttpResponse[typing.AsyncIterator[ChunkWorkflowMessage]]]:
        """
        Execute a workflow. Cannot be executed if there is no published workflow.

        Parameters
        ----------
        inputs : typing.Dict[str, typing.Optional[typing.Any]]
            Allows passing values for variables defined in the App.
            The inputs parameter contains multiple key/value pairs, where each key corresponds to a specific variable and each value is the specific value for that variable. Variables can be of file list type.
            File list type variables are suitable for passing files combined with text understanding to answer questions, only available when the model supports parsing capabilities for that type of file. If the variable is a file list type, the value corresponding to the variable should be in list format, where each element should include the following:
              - `type` (string) Supported types:
                - `document` Specific types include: 'TXT', 'MD', 'MARKDOWN', 'PDF', 'HTML', 'XLSX', 'XLS', 'DOCX', 'CSV', 'EML', 'MSG', 'PPTX', 'PPT', 'XML', 'EPUB'
                - `image` Specific types include: 'JPG', 'JPEG', 'PNG', 'GIF', 'WEBP', 'SVG'
                - `audio` Specific types include: 'MP3', 'M4A', 'WAV', 'WEBM', 'AMR'
                - `video` Specific types include: 'MP4', 'MOV', 'MPEG', 'MPGA'
                - `custom` Specific types include: other file types
              - `transfer_method` (string) Transfer method, `remote_url` image address / `local_file` uploaded file
              - `url` (string) Image address (only when the transfer method is `remote_url`)
              - `upload_file_id` (string) Upload file ID (only when the transfer method is `local_file`)

        response_mode : RunWorkflowRequestResponseMode
            Response mode, supports:
            - `streaming` Streaming mode (recommended). Implements streaming return similar to typewriter output based on SSE (Server-Sent Events).
            - `blocking` Blocking mode, waits for execution to complete before returning results. (Requests may be interrupted if the process is lengthy).
            Due to Cloudflare limitations, requests will be interrupted after 100 seconds of timeout with no response.

        user : str
            User identifier, used to define the identity of the end user, for easy retrieval and statistics.
            Rules defined by the developer, the user identifier must be unique within the application. API cannot access sessions created by WebApp.

        files : typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]]
            Optional file list

        trace_id : typing.Optional[str]
            Tracing ID. Suitable for integrating with existing trace components in business systems to achieve end-to-end distributed tracing. If not specified, the system will automatically generate a `trace_id`. Supports the following three transmission methods, with priorities as follows:
            1. Header: Recommended to pass through HTTP Header `X-Trace-Id`, highest priority.
            2. Query parameter: Pass through URL query parameter `trace_id`.
            3. Request Body: Pass through request body field `trace_id` (this field).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.AsyncIterator[AsyncHttpResponse[typing.AsyncIterator[ChunkWorkflowMessage]]]
            Successful response
        """
        async with self._client_wrapper.httpx_client.stream(
            "workflows/run",
            method="POST",
            json={
                "inputs": inputs,
                "response_mode": response_mode,
                "user": user,
                "files": files,
                "trace_id": trace_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        ) as _response:

            async def stream() -> AsyncHttpResponse[typing.AsyncIterator[ChunkWorkflowMessage]]:
                try:
                    if 200 <= _response.status_code < 300:

                        async def _iter():
                            async for _text in _response.aiter_lines():
                                try:
                                    _text = _text.removeprefix("data: ")

                                    if len(_text) == 0:
                                        continue
                                    yield typing.cast(
                                        ChunkWorkflowMessage,
                                        parse_obj_as(
                                            type_=ChunkWorkflowMessage,  # type: ignore
                                            object_=json.loads(_text),
                                        ),
                                    )
                                except Exception:
                                    pass
                            return

                        return AsyncHttpResponse(response=_response, data=_iter())
                    await _response.aread()
                    if _response.status_code == 400:
                        raise BadRequestError(
                            typing.cast(
                                typing.Optional[typing.Any],
                                parse_obj_as(
                                    type_=typing.Optional[typing.Any],  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    if _response.status_code == 404:
                        raise NotFoundError(
                            typing.cast(
                                typing.Optional[typing.Any],
                                parse_obj_as(
                                    type_=typing.Optional[typing.Any],  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    if _response.status_code == 500:
                        raise InternalServerError(
                            typing.cast(
                                Error,
                                parse_obj_as(
                                    type_=Error,  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise ApiError(
                        headers=dict(_response.headers), status_code=_response.status_code, body=_response.text
                    )
                raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

            yield await stream()

    @contextlib.asynccontextmanager
    async def run_specific_workflow(
        self,
        workflow_id: str,
        *,
        inputs: typing.Dict[str, typing.Optional[typing.Any]],
        response_mode: RunSpecificWorkflowRequestResponseMode,
        user: str,
        files: typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]] = OMIT,
        trace_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[AsyncHttpResponse[typing.AsyncIterator[ChunkWorkflowMessage]]]:
        """
        Execute a specific version of the workflow, specifying the workflow ID through the path parameter

        Parameters
        ----------
        workflow_id : str
            Workflow ID, used to specify a specific version of the workflow. How to obtain: You can query the specific version workflow ID in the version history.

        inputs : typing.Dict[str, typing.Optional[typing.Any]]
            Allows passing values for variables defined in the App.
            The inputs parameter contains multiple key/value pairs, where each key corresponds to a specific variable and each value is the specific value for that variable. Variables can be of file list type.
            File list type variables are suitable for passing files combined with text understanding to answer questions, only available when the model supports parsing capabilities for that type of file. If the variable is a file list type, the value corresponding to the variable should be in list format, where each element should include the following:
              - `type` (string) Supported types:
                - `document` Specific types include: 'TXT', 'MD', 'MARKDOWN', 'PDF', 'HTML', 'XLSX', 'XLS', 'DOCX', 'CSV', 'EML', 'MSG', 'PPTX', 'PPT', 'XML', 'EPUB'
                - `image` Specific types include: 'JPG', 'JPEG', 'PNG', 'GIF', 'WEBP', 'SVG'
                - `audio` Specific types include: 'MP3', 'M4A', 'WAV', 'WEBM', 'AMR'
                - `video` Specific types include: 'MP4', 'MOV', 'MPEG', 'MPGA'
                - `custom` Specific types include: other file types
              - `transfer_method` (string) Transfer method, `remote_url` image address / `local_file` uploaded file
              - `url` (string) Image address (only when the transfer method is `remote_url`)
              - `upload_file_id` (string) Upload file ID (only when the transfer method is `local_file`)

        response_mode : RunSpecificWorkflowRequestResponseMode
            Response mode, supports:
            - `streaming` Streaming mode (recommended). Implements streaming return similar to typewriter output based on SSE (Server-Sent Events).
            - `blocking` Blocking mode, waits for execution to complete before returning results. (Requests may be interrupted if the process is lengthy).
            Due to Cloudflare limitations, requests will be interrupted after 100 seconds of timeout with no response.

        user : str
            User identifier, used to define the identity of the end user, for easy retrieval and statistics.
            Rules defined by the developer, the user identifier must be unique within the application. API cannot access sessions created by WebApp.

        files : typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]]
            Optional file list

        trace_id : typing.Optional[str]
            Tracing ID. Suitable for integrating with existing trace components in business systems to achieve end-to-end distributed tracing. If not specified, the system will automatically generate a `trace_id`. Supports the following three transmission methods, with priorities as follows:
            1. Header: Recommended to pass through HTTP Header `X-Trace-Id`, highest priority.
            2. Query parameter: Pass through URL query parameter `trace_id`.
            3. Request Body: Pass through request body field `trace_id` (this field).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.AsyncIterator[AsyncHttpResponse[typing.AsyncIterator[ChunkWorkflowMessage]]]
            Successful response
        """
        async with self._client_wrapper.httpx_client.stream(
            f"workflows/{jsonable_encoder(workflow_id)}/run",
            method="POST",
            json={
                "inputs": inputs,
                "response_mode": response_mode,
                "user": user,
                "files": files,
                "trace_id": trace_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        ) as _response:

            async def stream() -> AsyncHttpResponse[typing.AsyncIterator[ChunkWorkflowMessage]]:
                try:
                    if 200 <= _response.status_code < 300:

                        async def _iter():
                            _event_source = httpx_sse.EventSource(_response)
                            async for _sse in _event_source.aiter_sse():
                                if _sse.data == None:
                                    return
                                try:
                                    yield _sse.data
                                except Exception:
                                    pass
                            return

                        return AsyncHttpResponse(response=_response, data=_iter())
                    await _response.aread()
                    if _response.status_code == 400:
                        raise BadRequestError(
                            typing.cast(
                                typing.Optional[typing.Any],
                                parse_obj_as(
                                    type_=typing.Optional[typing.Any],  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    if _response.status_code == 404:
                        raise NotFoundError(
                            typing.cast(
                                typing.Optional[typing.Any],
                                parse_obj_as(
                                    type_=typing.Optional[typing.Any],  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    if _response.status_code == 500:
                        raise InternalServerError(
                            typing.cast(
                                Error,
                                parse_obj_as(
                                    type_=Error,  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise ApiError(
                        headers=dict(_response.headers), status_code=_response.status_code, body=_response.text
                    )
                raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

            yield await stream()

    async def get_workflow_execution_status(
        self, workflow_run_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetWorkflowExecutionStatusResponse]:
        """
        Get the current execution result of a workflow task based on the workflow execution ID

        Parameters
        ----------
        workflow_run_id : str
            Workflow run ID, can be obtained from the streaming response chunks

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetWorkflowExecutionStatusResponse]
            Successfully retrieved workflow execution status
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/run/{jsonable_encoder(workflow_run_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetWorkflowExecutionStatusResponse,
                    parse_obj_as(
                        type_=GetWorkflowExecutionStatusResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def stop_workflow(
        self, task_id: str, *, user: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[StopWorkflowResponse]:
        """
        Only supports streaming mode

        Parameters
        ----------
        task_id : str
            Task ID, can be obtained from the streaming response chunks

        user : str
            User identifier, must be consistent with the user passed in the message sending interface. API cannot access sessions created by WebApp.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[StopWorkflowResponse]
            Successfully stopped the response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"workflows/tasks/{jsonable_encoder(task_id)}/stop",
            method="POST",
            json={
                "user": user,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StopWorkflowResponse,
                    parse_obj_as(
                        type_=StopWorkflowResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def get_workflow_logs(
        self,
        *,
        keyword: typing.Optional[str] = None,
        status: typing.Optional[GetWorkflowLogsRequestStatus] = None,
        page: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        created_by_end_user_session_id: typing.Optional[str] = None,
        created_by_account: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[GetWorkflowLogsResponse]:
        """
        Return workflow logs in reverse order

        Parameters
        ----------
        keyword : typing.Optional[str]
            Keyword

        status : typing.Optional[GetWorkflowLogsRequestStatus]
            Execution status: succeeded/failed/stopped

        page : typing.Optional[int]
            Current page number, default 1

        limit : typing.Optional[int]
            Items per page, default 20

        created_by_end_user_session_id : typing.Optional[str]
            Created by which end user session, e.g., `abc-123`

        created_by_account : typing.Optional[str]
            Created by which email account, e.g., lizb@test.com

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetWorkflowLogsResponse]
            Successfully retrieved workflow logs
        """
        _response = await self._client_wrapper.httpx_client.request(
            "workflows/logs",
            method="GET",
            params={
                "keyword": keyword,
                "status": status,
                "page": page,
                "limit": limit,
                "created_by_end_user_session_id": created_by_end_user_session_id,
                "created_by_account": created_by_account,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetWorkflowLogsResponse,
                    parse_obj_as(
                        type_=GetWorkflowLogsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def upload_file(
        self, *, file: core.File, user: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[UploadFileResponse]:
        """
        Upload a file to use when sending messages, enabling multimodal understanding. Supports any format supported by your workflow. Uploaded files are only available to the current end user.

        Parameters
        ----------
        file : core.File
            See core.File for more documentation

        user : str
            User identifier, used to define the identity of the end user, must be consistent with the user passed in the message sending interface

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[UploadFileResponse]
            File uploaded successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            "files/upload",
            method="POST",
            data={
                "user": user,
            },
            files={
                "file": file,
            },
            headers={
                # "content-type": "multipart/form-data",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UploadFileResponse,
                    parse_obj_as(
                        type_=UploadFileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 413:
                raise ContentTooLargeError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    @contextlib.asynccontextmanager
    async def preview_file(
        self,
        file_id: str,
        *,
        as_attachment: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[AsyncHttpResponse[typing.AsyncIterator[bytes]]]:
        """
        Preview or download uploaded files. This endpoint allows you to access files previously uploaded through the file upload API. Files can only be accessed within the message scope belonging to the requesting application.

        Parameters
        ----------
        file_id : str
            Unique identifier of the file to preview, obtained from the file upload API response

        as_attachment : typing.Optional[bool]
            Whether to force the file to be downloaded as an attachment. Defaults to `false` (preview in browser)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration. You can pass in configuration such as `chunk_size`, and more to customize the request and response.

        Returns
        -------
        typing.AsyncIterator[AsyncHttpResponse[typing.AsyncIterator[bytes]]]
            Successfully retrieved file content
        """
        async with self._client_wrapper.httpx_client.stream(
            f"files/{jsonable_encoder(file_id)}/preview",
            method="GET",
            params={
                "as_attachment": as_attachment,
            },
            request_options=request_options,
        ) as _response:

            async def stream() -> AsyncHttpResponse[typing.AsyncIterator[bytes]]:
                try:
                    if 200 <= _response.status_code < 300:
                        _chunk_size = request_options.get("chunk_size", None) if request_options is not None else None
                        return AsyncHttpResponse(
                            response=_response,
                            data=(_chunk async for _chunk in _response.aiter_bytes(chunk_size=_chunk_size)),
                        )
                    await _response.aread()
                    if _response.status_code == 400:
                        raise BadRequestError(
                            typing.cast(
                                typing.Optional[typing.Any],
                                parse_obj_as(
                                    type_=typing.Optional[typing.Any],  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    if _response.status_code == 403:
                        raise ForbiddenError(
                            typing.cast(
                                typing.Optional[typing.Any],
                                parse_obj_as(
                                    type_=typing.Optional[typing.Any],  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    if _response.status_code == 404:
                        raise NotFoundError(
                            typing.cast(
                                typing.Optional[typing.Any],
                                parse_obj_as(
                                    type_=typing.Optional[typing.Any],  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    if _response.status_code == 500:
                        raise InternalServerError(
                            typing.cast(
                                Error,
                                parse_obj_as(
                                    type_=Error,  # type: ignore
                                    object_=_response.json(),
                                ),
                            )
                        )
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise ApiError(
                        headers=dict(_response.headers), status_code=_response.status_code, body=_response.text
                    )
                raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

            yield await stream()

    async def get_app_info(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetAppInfoResponse]:
        """
        Used to get basic information about the application

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetAppInfoResponse]
            Successfully retrieved application information
        """
        _response = await self._client_wrapper.httpx_client.request(
            "info",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAppInfoResponse,
                    parse_obj_as(
                        type_=GetAppInfoResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def get_app_parameters(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetAppParametersResponse]:
        """
        Used at the beginning of page entry to get feature switches, input parameter names, types, and default values

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetAppParametersResponse]
            Successfully retrieved application parameters
        """
        _response = await self._client_wrapper.httpx_client.request(
            "parameters",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAppParametersResponse,
                    parse_obj_as(
                        type_=GetAppParametersResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)

    async def get_app_site(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetAppSiteResponse]:
        """
        Used to get the WebApp settings of the application

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetAppSiteResponse]
            Successfully retrieved application WebApp settings
        """
        _response = await self._client_wrapper.httpx_client.request(
            "site",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetAppSiteResponse,
                    parse_obj_as(
                        type_=GetAppSiteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response.text)
        raise ApiError(headers=dict(_response.headers), status_code=_response.status_code, body=_response_json)
